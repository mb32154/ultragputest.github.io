<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <!-- SEO CORE -->
    <title>Ultra GPU Stress Test | Online RTX & GPU Benchmark Tool</title>
    <meta name="google-site-verification" content="KSAN_Vy1_JtX4G6V3J1DwMf76EVeptWcv_euu_NV3r0" />
    <meta name="description" content="Ultra GPU Stress Test is a powerful online GPU & RTX benchmark tool. Test your graphics card under extreme load directly in your browser.">

    <meta name="keywords" content="Ultra GPU Stress Test, GPU stress test, RTX stress test, GPU benchmark online, test GPU online, RTX benchmark">

    <meta name="robots" content="index, follow">
    <meta name="author" content="Ultra GPU Stress Test">

    <!-- OpenGraph (Google + Social) -->
    <meta property="og:title" content="Ultra GPU Stress Test">
    <meta property="og:description" content="Extreme online GPU stress test and RTX benchmark. Push your graphics card to the limit.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ultragputest.com">
    <meta property="og:image" content="https://ultragputest.com/preview.jpg">

    <!-- Canonical -->
    <link rel="canonical" href="https://ultragputest.com/">

    <meta name="viewport" content="width=device-width, initial-scale=20.0">
    <title>Ultra Heavy GPU Stress Test Pro - Ultimate GPU Benchmark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: #000000;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            background: radial-gradient(circle at 50% 50%, #0a0a2a 0%, #000000 100%);
            padding-top: 80px;
        }

        .container {
            max-width: 2000px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Fixed Header */
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 10, 20, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #00ccff;
            z-index: 1000;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .header-title {
            font-size: 1.5rem;
            background: linear-gradient(90deg, #ff0066, #00ffcc, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Language Selector */
        .language-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .lang-btn {
            background: rgba(0, 50, 100, 0.9);
            border: 2px solid #00ccff;
            color: #00ccff;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .lang-btn:hover {
            background: rgba(0, 100, 200, 0.9);
            transform: scale(1.05);
        }

        .lang-btn.active {
            background: #00ccff;
            color: #000;
            border-color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
        }

        /* Header */
        .header {
            text-align: center;
            padding: 30px 20px;
            margin-bottom: 30px;
            background: linear-gradient(90deg, 
                rgba(255, 0, 102, 0.3), 
                rgba(0, 255, 204, 0.3), 
                rgba(0, 102, 255, 0.3));
            border-radius: 20px;
            border: 2px solid #ff0066;
            position: relative;
            overflow: hidden;
        }

        .header h1 {
            font-size: 3.5rem;
            background: linear-gradient(90deg, #ff0066, #00ffcc, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 30px rgba(255, 0, 102, 0.5);
        }

        .header h2 {
            font-size: 1.8rem;
            color: #00ffcc;
            opacity: 0.9;
            font-weight: 300;
        }

        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 1600px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Side Panels */
        .side-panel {
            background: rgba(10, 10, 30, 0.95);
            border: 2px solid #0066ff;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 102, 255, 0.3);
        }

        .panel-title {
            color: #00ccff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #00ccff;
            text-align: center;
        }

        /* Test Selection - Compact */
        .test-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .test-item {
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #0099ff;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-item:hover {
            transform: translateY(-5px);
            border-color: #00ffcc;
            box-shadow: 0 10px 20px rgba(0, 255, 204, 0.3);
        }

        .test-item.active {
            background: linear-gradient(135deg, rgba(0, 80, 160, 0.9), rgba(0, 160, 200, 0.9));
            border-color: #00ffcc;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
        }

        .test-name {
            color: #00ccff;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        /* Canvas Container */
        .canvas-container {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0066;
            border-radius: 20px;
            padding: 20px;
            min-height: 850px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(255, 0, 102, 0.3);
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ff0066;
        }

        .current-test {
            color: #ffcc00;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
        }

        .performance-display {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .fps-counter {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 15px;
            padding: 20px 30px;
            text-align: center;
            min-width: 200px;
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.3);
        }

        .fps-label {
            color: #00ffcc;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .fps-value {
            color: #00ffcc;
            font-size: 3.2rem;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
            transition: all 0.3s ease;
            direction: ltr;
        }

        /* Fullscreen Toggle Button */
        .fullscreen-toggle {
            background: rgba(0, 50, 100, 0.9);
            border: 2px solid #00ffcc;
            color: #00ffcc;
            width: 50px;
            height: 50px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .fullscreen-toggle:hover {
            background: rgba(0, 100, 200, 0.9);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }

        /* Canvas */
        #gameCanvas {
            width: 100%;
            height: 650px;
            background: #000;
            border-radius: 15px;
            border: 2px solid #00ccff;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.2);
        }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 25px;
        }

        .control-btn {
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .start-btn {
            background: linear-gradient(135deg, #006600, #00aa00, #00ff00);
            color: white;
        }

        .start-btn:hover {
            background: linear-gradient(135deg, #00aa00, #00ff00, #00ff44);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 255, 0, 0.4);
        }

        .stop-btn {
            background: linear-gradient(135deg, #990000, #cc0000, #ff0000);
            color: white;
        }

        .stop-btn:hover {
            background: linear-gradient(135deg, #cc0000, #ff0000, #ff3333);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 0, 0, 0.4);
        }

        .unlock-btn {
            background: linear-gradient(135deg, #660066, #990099, #cc00cc);
            color: white;
        }

        .unlock-btn:hover {
            background: linear-gradient(135deg, #990099, #cc00cc, #ff33ff);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(204, 0, 204, 0.4);
        }

        .unlock-btn.active {
            background: linear-gradient(135deg, #00aa00, #00ff00, #00ff44);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .reset-btn {
            background: linear-gradient(135deg, #006666, #009999, #00cccc);
            color: white;
        }

        .reset-btn:hover {
            background: linear-gradient(135deg, #009999, #00cccc, #00ffff);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 204, 204, 0.4);
        }

        /* Fullscreen Mode Styles */
        body.fullscreen-mode {
            padding: 0;
            background: #000;
        }

        body.fullscreen-mode .fixed-header,
        body.fullscreen-mode .header,
        body.fullscreen-mode .side-panel,
        body.fullscreen-mode .footer,
        body.fullscreen-mode .results-panel,
        body.fullscreen-mode .controls {
            display: none !important;
        }

        body.fullscreen-mode .container {
            max-width: 100%;
            padding: 0;
            margin: 0;
        }

        body.fullscreen-mode .main-content {
            display: block;
            margin: 0;
        }

        body.fullscreen-mode .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            border: none;
            border-radius: 0;
            padding: 0;
            margin: 0;
            z-index: 9999;
        }

        body.fullscreen-mode #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            margin: 0;
        }

        /* Fullscreen Controls Overlay */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            pointer-events: none;
            display: none;
        }

        body.fullscreen-mode .fullscreen-overlay {
            display: block;
        }

        .fullscreen-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            pointer-events: auto;
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #00ffcc;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.3);
        }

        .fullscreen-fps {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            padding: 10px 20px;
            min-width: 150px;
            text-align: center;
        }

        .fullscreen-fps-label {
            color: #00ffcc;
            font-size: 1rem;
            margin-bottom: 5px;
        }

        .fullscreen-fps-value {
            color: #00ffcc;
            font-size: 2.5rem;
            font-weight: bold;
            direction: ltr;
        }

        .exit-fullscreen-btn {
            background: linear-gradient(135deg, #990000, #cc0000, #ff0000);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .exit-fullscreen-btn:hover {
            background: linear-gradient(135deg, #cc0000, #ff0000, #ff3333);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        /* Fullscreen Stop Button */
        .fullscreen-stop-btn {
            background: linear-gradient(135deg, #990000, #cc0000, #ff0000);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .fullscreen-stop-btn:hover {
            background: linear-gradient(135deg, #cc0000, #ff0000, #ff3333);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        /* Results Panel */
        .results-panel {
            background: rgba(10, 10, 30, 0.98);
            border: 3px solid #00ffcc;
            border-radius: 20px;
            padding: 30px;
            margin-top: 40px;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.3);
        }

        .results-panel.active {
            display: block;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(40px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .results-title {
            color: #00ffcc;
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }

        .score-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .score-card {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            border: 3px solid #ff0066;
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.2);
        }

        .score-label {
            color: #ff0066;
            font-size: 1.2rem;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .score-value {
            color: #ff0066;
            font-size: 3rem;
            font-weight: bold;
            direction: ltr;
        }

        .results-details {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: #aaddff;
            font-size: 1.1rem;
        }

        .detail-value {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
            direction: ltr;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .loading-screen.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 100px;
            height: 100px;
            border: 10px solid #00ffcc;
            border-top: 10px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        .loading-text {
            color: #00ffcc;
            font-size: 1.6rem;
            text-align: center;
            max-width: 600px;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            margin-bottom: 15px;
        }

        .progress-container {
            width: 400px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ffcc, #0066ff, #ff0066);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.3) 50%, 
                transparent 100%);
            animation: shimmer 2s infinite;
        }

        .progress-percent {
            color: #00ffcc;
            font-size: 1.1rem;
            margin-top: 8px;
            direction: ltr;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            color: #8899aa;
            font-size: 1rem;
            background: rgba(0, 10, 20, 0.5);
            border-radius: 15px;
        }

        /* Pressure Controls */
        .pressure-controls {
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 30, 60, 0.7);
            border-radius: 10px;
            border: 1px solid #0099ff;
        }

        .slider-container {
            margin: 12px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: #00ccff;
        }

        .slider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            background: rgba(0, 60, 120, 0.5);
            border-radius: 12px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00ffcc;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 40, 80, 0.95);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            padding: 15px 25px;
            color: #00ffcc;
            font-size: 1.1rem;
            z-index: 3000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 255, 204, 0.3);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        /* System Performance */
        .system-info {
            margin-top: 8px;
            font-size: 0.9rem;
            color: #aaddff;
            text-align: center;
        }

        /* Enhanced Background Elements */
        .bg-particle {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        /* Warning Modal */
        .warning-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .warning-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .warning-content {
            background: linear-gradient(135deg, #0a0a2a, #000033);
            border: 3px solid #ff0066;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.5);
            backdrop-filter: blur(10px);
        }

        .warning-title {
            color: #ff0066;
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
        }

        .warning-text {
            color: #ffffff;
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            white-space: pre-line;
        }

        .warning-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .warning-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .warning-confirm {
            background: linear-gradient(135deg, #ff0066, #cc0000);
            color: white;
        }

        .warning-confirm:hover {
            background: linear-gradient(135deg, #ff3366, #ff0000);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.5);
        }

        .warning-cancel {
            background: linear-gradient(135deg, #0066ff, #0033aa);
            color: white;
        }

        .warning-cancel:hover {
            background: linear-gradient(135deg, #3399ff, #0066ff);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 102, 255, 0.5);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .header h1 {
                font-size: 2.8rem;
            }
            
            .main-content {
                gap: 15px;
            }
            
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .score-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            #gameCanvas {
                height: 550px;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header h2 {
                font-size: 1.4rem;
            }
            
            .current-test {
                font-size: 1.5rem;
            }
            
            .fps-counter {
                min-width: 150px;
                padding: 15px;
            }
            
            .fps-value {
                font-size: 2.5rem;
            }
            
            .controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .control-btn {
                padding: 15px;
                font-size: 1rem;
            }
            
            .fixed-header {
                flex-direction: column;
                gap: 8px;
                padding: 8px;
            }
            
            .progress-container {
                width: 300px;
            }
            
            .warning-content {
                padding: 20px;
                margin: 20px;
            }
            
            .warning-buttons {
                flex-direction: column;
            }
            
            .warning-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Ultra GPU Stress Test</h1>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Warning Modal -->
    <div class="warning-modal" id="warningModal">
        <div class="warning-content">
            <div class="warning-title" id="warningTitle">‚ö†Ô∏è WARNING</div>
            <div class="warning-text" id="warningText">This is an EXTREME GPU stress test!

This test will push your GPU to its absolute limits.

Make sure your cooling system is adequate.

Do you want to continue?</div>
            <div class="warning-buttons">
                <button class="warning-btn warning-confirm" id="warningConfirm">CONTINUE</button>
                <button class="warning-btn warning-cancel" id="warningCancel">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="fullscreen-controls">
            <button class="exit-fullscreen-btn" id="exitFullscreenBtn">
                <span>‚§´</span>
                <span>Exit Fullscreen</span>
            </button>
            <div class="fullscreen-fps">
                <div class="fullscreen-fps-label">FPS</div>
                <div class="fullscreen-fps-value" id="fullscreenFpsValue">60</div>
            </div>
            <button class="fullscreen-stop-btn" id="fullscreenStopBtn">
                <span>‚èπÔ∏è</span>
                <span>Stop Test</span>
            </button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Loading Extreme GPU Stress Test...</div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="progress-percent" id="progressPercent">0%</div>
    </div>

    <!-- Fixed Header with Language Selector -->
    <div class="fixed-header">
        <div class="header-title">GPU Stress Test Pro - Ultimate GPU Benchmark</div>
        <div class="language-selector">
            <button class="lang-btn active" data-lang="en">üá∫üá∏ English</button>
            <button class="lang-btn" data-lang="fa">üáÆüá∑ ŸÅÿßÿ±ÿ≥€å</button>
            <button class="lang-btn" data-lang="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</button>
            <button class="lang-btn" data-lang="zh">üá®üá≥ ‰∏≠Êñá</button>
            <button class="lang-btn" data-lang="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</button>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 id="mainTitle">Ultra Heavy GPU Stress Test</h1>
            <h2 id="subTitle">Ultimate Edition - Compatible with All GPUs</h2>
            <div class="system-info" id="systemInfo">System ready - Select a test to begin</div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel - Test Selection -->
            <div class="side-panel">
                <div class="panel-title" id="testSelectionTitle">Test Selection</div>
                <div class="test-selection">
                    <div class="test-item active" data-test="raytrace">
                        <div class="test-name">
                            <span id="test1Name">Extreme Ray Tracing</span>
                            <span>üí•</span>
                        </div>
                    </div>
                    
                    <div class="test-item" data-test="volumetric">
                        <div class="test-name">
                            <span id="test2Name">Volumetric Fog</span>
                            <span>üå´Ô∏è</span>
                        </div>
                    </div>
                    
                    <div class="test-item" data-test="particles">
                        <div class="test-name">
                            <span id="test3Name">Particle Physics</span>
                            <span>‚ú®</span>
                        </div>
                    </div>
                    
                    <div class="test-item" data-test="texture">
                        <div class="test-name">
                            <span id="test4Name">Texture Streaming</span>
                            <span>üé®</span>
                        </div>
                    </div>
                    
                    <div class="test-item" data-test="volume_shader">
                        <div class="test-name">
                            <span id="test5Name">Extreme Volume Shader</span>
                            <span>üî•</span>
                        </div>
                    </div>
                </div>

                <div class="panel-title" style="margin-top: 25px;" id="settingsTitle">Settings</div>
                <div class="pressure-controls">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span id="qualityLabel">Graphics Quality:</span>
                            <span id="qualityValue">100%</span>
                        </div>
                        <input type="range" min="1" max="100" value="100" class="slider" id="qualitySlider">
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.8rem; color: #aaddff;">
                            <span>1%</span>
                            <span>25%</span>
                            <span>50%</span>
                            <span>75%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span id="pressureLabel">Pressure Level:</span>
                            <span id="pressureValue">100%</span>
                        </div>
                        <input type="range" min="1" max="100" value="100" class="slider" id="pressureSlider">
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.8rem; color: #aaddff;">
                            <span>1%</span>
                            <span>25%</span>
                            <span>50%</span>
                            <span>75%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span id="resolutionLabel">FPS Limit:</span>
                            <span id="resolutionValue">360</span>
                        </div>
                        <input type="range" min="1" max="360" value="360" class="slider" id="resolutionSlider">
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.8rem; color: #aaddff;">
                            <span>1</span>
                            <span>90</span>
                            <span>180</span>
                            <span>270</span>
                            <span>360</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Panel - Canvas -->
            <div class="canvas-container">
                <div class="canvas-header">
                    <div class="current-test" id="currentTestTitle">Extreme Ray Tracing</div>
                    <div class="performance-display">
                        <div class="fps-counter">
                            <div class="fps-label" id="fpsLabel">FPS</div>
                            <div class="fps-value" id="fpsValue">60</div>
                        </div>
                        <div class="fullscreen-toggle" id="fullscreenToggle" title="Toggle Fullscreen">
                            ‚õ∂
                        </div>
                    </div>
                </div>

                <canvas id="gameCanvas"></canvas>

                <div class="controls">
                    <button class="control-btn start-btn" id="startBtn">
                        <span>‚ñ∂Ô∏è</span>
                        <span id="startBtnText">Start Test</span>
                    </button>
                    <button class="control-btn stop-btn" id="stopBtn" disabled>
                        <span>‚èπÔ∏è</span>
                        <span id="stopBtnText">Stop Test</span>
                    </button>
                    <button class="control-btn unlock-btn active" id="unlockBtn">
                        <span>üöÄ</span>
                        <span id="unlockBtnText">Unlocked FPS</span>
                    </button>
                    <button class="control-btn reset-btn" id="resetBtn">
                        <span>üîÑ</span>
                        <span id="resetBtnText">Reset</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Panel -->
        <div class="results-panel" id="resultsPanel">
            <div class="results-title" id="resultsTitle">Test Results</div>
            
            <div class="score-grid">
                <div class="score-card">
                    <div class="score-label" id="score1Label">Overall Score</div>
                    <div class="score-value" id="score1Value">0</div>
                </div>
                
                <div class="score-card">
                    <div class="score-label" id="score2Label">Average FPS</div>
                    <div class="score-value" id="score2Value">0</div>
                </div>
                
                <div class="score-card">
                    <div class="score-label" id="score3Label">Stability</div>
                    <div class="score-value" id="score3Value">0%</div>
                </div>
            </div>
            
            <div class="results-details">
                <div class="detail-row">
                    <div class="detail-label" id="detail1Label">Test Duration:</div>
                    <div class="detail-value" id="detail1Value">0s</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label" id="detail2Label">Max FPS:</div>
                    <div class="detail-value" id="detail2Value">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label" id="detail3Label">Min FPS:</div>
                    <div class="detail-value" id="detail3Value">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label" id="detail4Label">Performance Level:</div>
                    <div class="detail-value" id="detail4Value">--</div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div id="footerText">Ultra Heavy GPU Stress Test v20.0 Ultimate Edition | Compatible with all graphics cards</div>
        </div>
    </div>

    <script>
        class UltraHeavyGPUTest {
            constructor() {
                this.animationId = null;
                this.idleAnimationId = null;
                this.testAnimationId = null;
                
                this.state = {
                    isRunning: false,
                    isUnlocked: true,
                    currentTest: 'raytrace',
                    currentLanguage: 'en',
                    fps: 60,
                    frameCount: 0,
                    startTime: 0,
                    lastFrameTime: 0,
                    fpsHistory: [],
                    testDuration: 0,
                    lastIdleFrameTime: 0,
                    idleAnimationActive: true,
                    isFullscreen: false,
                    
                    fpsSmoothing: [],
                    fpsSmoothingLength: 10,
                    
                    results: {
                        minFPS: 9999,
                        maxFPS: 0,
                        avgFPS: 0,
                        stability: 0,
                        overallScore: 0
                    },
                    
                    sceneObjects: [],
                    particles: [],
                    fogData: null,
                    textures: [],
                    volumeShaders: [],
                    
                    settings: {
                        qualityLevel: 100,
                        pressureLevel: 100,
                        fpsLimit: 360
                    },

                    performanceData: {
                        frameTimes: []
                    },
                    
                    initializationProgress: 0,
                    initializationComplete: false,
                    
                    // ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ®ÿ±ÿß€å ÿ∞ÿ±ÿßÿ™ Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá
                    bgParticles: []
                };
                
                this.init();
            }
            
            init() {
                console.log('üöÄ Initializing Ultra Heavy GPU Stress Test...');
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                this.setupEventListeners();
                this.setupLanguageSystem();
                this.updateSettingsDisplay();
                this.createBackgroundParticles();
                this.startIdleAnimation();
                this.setupFullscreenListeners();
                
                console.log('‚úÖ Ultra Heavy GPU Stress Test ready!');
            }
            
            resizeCanvas() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
            }
            
            createBackgroundParticles() {
                // ÿß€åÿ¨ÿßÿØ 500 ÿ∞ÿ±Ÿá ÿ®ÿ±ÿß€å Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá
                for (let i = 0; i < 500; i++) {
                    this.state.bgParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: 0.5 + Math.random() * 3,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: (Math.random() - 0.5) * 0.5,
                        color: `rgba(${Math.floor(Math.random() * 100 + 155)}, ${Math.floor(Math.random() * 100 + 155)}, 255, ${0.1 + Math.random() * 0.3})`,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.02
                    });
                }
            }
            
            setupEventListeners() {
                console.log('üîó Setting up event listeners...');
                
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    if (this.state.isFullscreen) {
                        this.handleFullscreenResize();
                    }
                });
                
                // Test selection events
                document.querySelectorAll('.test-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        console.log('Test clicked:', item.dataset.test);
                        if (this.state.isRunning) {
                            this.showToast('Please stop the current test first');
                            return;
                        }
                        
                        document.querySelectorAll('.test-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        this.state.currentTest = item.dataset.test;
                        this.updateTestTitle();
                        this.clearCanvas();
                        this.startIdleAnimation();
                    });
                });
                
                // Sliders
                document.getElementById('qualitySlider').addEventListener('input', (e) => {
                    this.state.settings.qualityLevel = parseInt(e.target.value);
                    this.updateSettingsDisplay();
                });
                
                document.getElementById('pressureSlider').addEventListener('input', (e) => {
                    this.state.settings.pressureLevel = parseInt(e.target.value);
                    this.updateSettingsDisplay();
                });
                
                document.getElementById('resolutionSlider').addEventListener('input', (e) => {
                    this.state.settings.fpsLimit = parseInt(e.target.value);
                    this.updateSettingsDisplay();
                });
                
                // Main control buttons
                document.getElementById('startBtn').addEventListener('click', () => {
                    console.log('üü¢ Start button clicked');
                    this.showWarningModal();
                });
                
                document.getElementById('stopBtn').addEventListener('click', () => {
                    console.log('üî¥ Stop button clicked');
                    this.stopTest();
                });
                
                document.getElementById('unlockBtn').addEventListener('click', () => {
                    console.log('üîì Unlock FPS button clicked');
                    this.toggleUnlock();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    console.log('üîÑ Reset button clicked');
                    this.resetAll();
                });
                
                // Language buttons
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.changeLanguage(btn.dataset.lang);
                    });
                });
                
                // Warning modal buttons
                document.getElementById('warningConfirm').addEventListener('click', () => {
                    this.hideWarningModal();
                    this.startTest();
                });
                
                document.getElementById('warningCancel').addEventListener('click', () => {
                    this.hideWarningModal();
                });
                
                // Fullscreen toggle
                document.getElementById('fullscreenToggle').addEventListener('click', () => {
                    this.toggleFullscreen();
                });
                
                // Exit fullscreen button
                document.getElementById('exitFullscreenBtn').addEventListener('click', () => {
                    this.exitFullscreen();
                });
                
                // Fullscreen stop button
                document.getElementById('fullscreenStopBtn').addEventListener('click', () => {
                    this.stopTest();
                    if (this.state.isFullscreen) {
                        this.exitFullscreen();
                    }
                });
                
                console.log('‚úÖ Event listeners set up');
            }
            
            setupFullscreenListeners() {
                // Listen for fullscreen change events
                document.addEventListener('fullscreenchange', () => {
                    this.state.isFullscreen = !!document.fullscreenElement;
                    this.updateFullscreenState();
                });
                
                document.addEventListener('webkitfullscreenchange', () => {
                    this.state.isFullscreen = !!document.webkitFullscreenElement;
                    this.updateFullscreenState();
                });
                
                document.addEventListener('mozfullscreenchange', () => {
                    this.state.isFullscreen = !!document.mozFullScreenElement;
                    this.updateFullscreenState();
                });
                
                document.addEventListener('MSFullscreenChange', () => {
                    this.state.isFullscreen = !!document.msFullscreenElement;
                    this.updateFullscreenState();
                });
            }
            
            toggleFullscreen() {
                if (!this.state.isFullscreen) {
                    this.enterFullscreen();
                } else {
                    this.exitFullscreen();
                }
            }
            
            enterFullscreen() {
                const canvasContainer = document.querySelector('.canvas-container');
                
                if (canvasContainer.requestFullscreen) {
                    canvasContainer.requestFullscreen();
                } else if (canvasContainer.webkitRequestFullscreen) {
                    canvasContainer.webkitRequestFullscreen();
                } else if (canvasContainer.mozRequestFullScreen) {
                    canvasContainer.mozRequestFullScreen();
                } else if (canvasContainer.msRequestFullscreen) {
                    canvasContainer.msRequestFullscreen();
                }
                
                this.state.isFullscreen = true;
                this.updateFullscreenState();
                this.showToast('Entered fullscreen mode');
            }
            
            exitFullscreen() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                
                this.state.isFullscreen = false;
                this.updateFullscreenState();
                this.showToast('Exited fullscreen mode');
            }
            
            updateFullscreenState() {
                if (this.state.isFullscreen) {
                    document.body.classList.add('fullscreen-mode');
                    this.handleFullscreenResize();
                } else {
                    document.body.classList.remove('fullscreen-mode');
                    this.resizeCanvas();
                }
            }
            
            handleFullscreenResize() {
                // Update canvas size for fullscreen
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Update FPS display in fullscreen
                document.getElementById('fullscreenFpsValue').textContent = this.state.fps;
                this.updateFullscreenFPSColor();
            }
            
            updateFullscreenFPSColor() {
                const fpsElement = document.getElementById('fullscreenFpsValue');
                const fps = this.state.fps;
                
                if (fps >= 300) {
                    fpsElement.style.color = '#00ff00';
                } else if (fps >= 240) {
                    fpsElement.style.color = '#80ff00';
                } else if (fps >= 180) {
                    fpsElement.style.color = '#ffff00';
                } else if (fps >= 120) {
                    fpsElement.style.color = '#ffaa00';
                } else if (fps >= 90) {
                    fpsElement.style.color = '#ff5500';
                } else if (fps >= 60) {
                    fpsElement.style.color = '#ff3300';
                } else {
                    fpsElement.style.color = '#ff0000';
                }
            }
            
            showWarningModal() {
                const modal = document.getElementById('warningModal');
                modal.classList.add('active');
            }
            
            hideWarningModal() {
                const modal = document.getElementById('warningModal');
                modal.classList.remove('active');
            }
            
            setupLanguageSystem() {
                this.translations = {
                    en: {
                        mainTitle: "Ultra Heavy GPU Stress Test",
                        subTitle: "Ultimate Edition - Compatible with All GPUs",
                        testSelectionTitle: "Test Selection",
                        test1Name: "Extreme Ray Tracing",
                        test2Name: "Volumetric Fog",
                        test3Name: "Particle Physics",
                        test4Name: "Texture Streaming",
                        test5Name: "Extreme Volume Shader",
                        settingsTitle: "Settings",
                        qualityLabel: "Graphics Quality:",
                        pressureLabel: "Pressure Level:",
                        resolutionLabel: "FPS Limit:",
                        fpsLabel: "FPS",
                        startBtnText: "Start Test",
                        stopBtnText: "Stop Test",
                        unlockBtnText: "Unlocked FPS",
                        resetBtnText: "Reset",
                        resultsTitle: "Test Results",
                        score1Label: "Overall Score",
                        score2Label: "Average FPS",
                        score3Label: "Stability",
                        detail1Label: "Test Duration:",
                        detail2Label: "Max FPS:",
                        detail3Label: "Min FPS:",
                        detail4Label: "Performance Level:",
                        footerText: "Ultra Heavy GPU Stress Test v20.0 Ultimate Edition | Compatible with all graphics cards",
                        warningTitle: "‚ö†Ô∏è WARNING",
                        warningText: "This is an EXTREME GPU stress test!\n\nThis test will push your GPU to its absolute limits.\n\nMake sure your cooling system is adequate.\n\nDo you want to continue?",
                        warningConfirm: "CONTINUE",
                        warningCancel: "CANCEL"
                    },
                    fa: {
                        mainTitle: "ÿ™ÿ≥ÿ™ ŸÅÿ¥ÿßÿ± ŸÅŸàŸÇ ÿ≥ŸÜ⁄Ø€åŸÜ GPU",
                        subTitle: "Ÿà€åÿ±ÿß€åÿ¥ Ultimate - ÿ≥ÿßÿ≤⁄Øÿßÿ± ÿ®ÿß ÿ™ŸÖÿßŸÖ ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß€å ⁄Øÿ±ÿßŸÅ€å⁄©",
                        testSelectionTitle: "ÿßŸÜÿ™ÿÆÿßÿ® ÿ™ÿ≥ÿ™",
                        test1Name: "ÿ±€å‚Äåÿ™ÿ±€åŸÜ⁄Ø ŸÅŸàŸÇ‚ÄåŸæ€åÿ¥ÿ±ŸÅÿ™Ÿá",
                        test2Name: "ŸÖŸá ÿ≠ÿ¨ŸÖ€å",
                        test3Name: "ŸÅ€åÿ≤€å⁄© ÿ∞ÿ±ÿßÿ™",
                        test4Name: "ÿßÿ≥ÿ™ÿ±€åŸÖ ÿ®ÿßŸÅÿ™",
                        test5Name: "ÿ¥€åÿØÿ± ÿ≠ÿ¨ŸÖ€å ÿ¥ÿØ€åÿØ",
                        settingsTitle: "ÿ™ŸÜÿ∏€åŸÖÿßÿ™",
                        qualityLabel: "⁄©€åŸÅ€åÿ™ ⁄Øÿ±ÿßŸÅ€å⁄©:",
                        pressureLabel: "ÿ≥ÿ∑ÿ≠ ŸÅÿ¥ÿßÿ±:",
                        resolutionLabel: "ŸÖÿ≠ÿØŸàÿØ€åÿ™ FPS:",
                        fpsLabel: "FPS",
                        startBtnText: "ÿ¥ÿ±Ÿàÿπ ÿ™ÿ≥ÿ™",
                        stopBtnText: "ÿ™ŸàŸÇŸÅ ÿ™ÿ≥ÿ™",
                        unlockBtnText: "FPS ÿ¢ÿ≤ÿßÿØ",
                        resetBtnText: "ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å",
                        resultsTitle: "ŸÜÿ™ÿß€åÿ¨ ÿ™ÿ≥ÿ™",
                        score1Label: "ÿßŸÖÿ™€åÿßÿ≤ ⁄©ŸÑ€å",
                        score2Label: "ŸÖ€åÿßŸÜ⁄Ø€åŸÜ FPS",
                        score3Label: "Ÿæÿß€åÿØÿßÿ±€å",
                        detail1Label: "ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ™ÿ≥ÿ™:",
                        detail2Label: "ÿ®€åÿ¥ÿ™ÿ±€åŸÜ FPS:",
                        detail3Label: "⁄©ŸÖÿ™ÿ±€åŸÜ FPS:",
                        detail4Label: "ÿ≥ÿ∑ÿ≠ ÿπŸÖŸÑ⁄©ÿ±ÿØ:",
                        footerText: "ÿ™ÿ≥ÿ™ ŸÅÿ¥ÿßÿ± ŸÅŸàŸÇ ÿ≥ŸÜ⁄Ø€åŸÜ GPU v20.0 Ÿà€åÿ±ÿß€åÿ¥ Ultimate | ÿ≥ÿßÿ≤⁄Øÿßÿ± ÿ®ÿß ÿ™ŸÖÿßŸÖ ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß€å ⁄Øÿ±ÿßŸÅ€å⁄©",
                        warningTitle: "‚ö†Ô∏è Ÿáÿ¥ÿØÿßÿ±",
                        warningText: "ÿß€åŸÜ €å⁄© ÿ™ÿ≥ÿ™ ŸÅÿ¥ÿßÿ± ŸÅŸàŸÇ‚Äåÿ≥ŸÜ⁄Ø€åŸÜ GPU ÿßÿ≥ÿ™!\n\nÿß€åŸÜ ÿ™ÿ≥ÿ™ ⁄©ÿßÿ±ÿ™ ⁄Øÿ±ÿßŸÅ€å⁄© ÿ¥ŸÖÿß ÿ±ÿß ÿ™ÿß ÿ≠ÿØ ŸÜŸáÿß€å€å ŸÅÿ¥ÿßÿ± ÿÆŸàÿßŸáÿØ ÿØÿßÿØ.\n\nŸÖÿ∑ŸÖÿ¶ŸÜ ÿ¥Ÿà€åÿØ ÿ≥€åÿ≥ÿ™ŸÖ ÿÆŸÜ⁄©‚Äå⁄©ŸÜŸÜÿØŸá ⁄©ÿßŸÅ€å ÿØÿßÿ±€åÿØ.\n\nÿ¢€åÿß ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßÿØÿßŸÖŸá ÿØŸá€åÿØÿü",
                        warningConfirm: "ÿßÿØÿßŸÖŸá",
                        warningCancel: "ŸÑÿ∫Ÿà"
                    },
                    ar: {
                        mainTitle: "ÿßÿÆÿ™ÿ®ÿßÿ± ÿ•ÿ¨ŸáÿßÿØ GPU ŸÅÿßÿ¶ŸÇ ÿßŸÑÿ´ŸÇŸÑ",
                        subTitle: "ÿßŸÑÿ•ÿµÿØÿßÿ± Ultimate - ŸÖÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿ¨ŸÖŸäÿπ ŸÉÿ±Ÿàÿ™ ÿßŸÑÿ¥ÿßÿ¥ÿ©",
                        testSelectionTitle: "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±",
                        test1Name: "ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ£ÿ¥ÿπÿ© ÿßŸÑŸÖÿ™ÿ∑ÿ±ŸÅ",
                        test2Name: "ÿ∂ÿ®ÿßÿ® ÿ≠ÿ¨ŸÖŸä",
                        test3Name: "ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑÿ¨ÿ≥ŸäŸÖÿßÿ™",
                        test4Name: "ÿØŸÅŸÇ ÿßŸÑŸÇŸàÿßŸÖ",
                        test5Name: "ÿ¥ÿßÿØÿ± ÿßŸÑÿ≠ÿ¨ŸÖŸä ÿßŸÑŸÖÿ™ÿ∑ÿ±ŸÅ",
                        settingsTitle: "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™",
                        qualityLabel: "ÿ¨ŸàÿØÿ© ÿßŸÑÿ±ÿ≥ŸàŸÖÿßÿ™:",
                        pressureLabel: "ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ∂ÿ∫ÿ∑:",
                        resolutionLabel: "ÿ≠ÿØ FPS:",
                        fpsLabel: "FPS",
                        startBtnText: "ÿ®ÿØÿ° ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±",
                        stopBtnText: "ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±",
                        unlockBtnText: "FPS ÿ∫Ÿäÿ± ŸÖŸÇŸäÿØ",
                        resetBtnText: "ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ",
                        resultsTitle: "ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±",
                        score1Label: "ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑÿπÿßŸÖÿ©",
                        score2Label: "ŸÖÿ™Ÿàÿ≥ÿ∑ FPS",
                        score3Label: "ÿßŸÑÿßÿ≥ÿ™ŸÇÿ±ÿßÿ±",
                        detail1Label: "ŸÖÿØÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±:",
                        detail2Label: "ÿ£ŸÇÿµŸâ FPS:",
                        detail3Label: "ÿ£ÿØŸÜŸâ FPS:",
                        detail4Label: "ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ£ÿØÿßÿ°:",
                        footerText: "ÿßÿÆÿ™ÿ®ÿßÿ± ÿ•ÿ¨ŸáÿßÿØ GPU ŸÅÿßÿ¶ŸÇ ÿßŸÑÿ´ŸÇŸÑ v20.0 ÿßŸÑÿ•ÿµÿØÿßÿ± Ultimate | ŸÖÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿ¨ŸÖŸäÿπ ŸÉÿ±Ÿàÿ™ ÿßŸÑÿ¥ÿßÿ¥ÿ©",
                        warningTitle: "‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±",
                        warningText: "Ÿáÿ∞ÿß ÿßÿÆÿ™ÿ®ÿßÿ± ÿ•ÿ¨ŸáÿßÿØ GPU ŸÅÿßÿ¶ŸÇ ÿßŸÑÿ´ŸÇŸÑ!\n\nŸáÿ∞ÿß ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿ≥ŸäÿØŸÅÿπ ÿ®ÿ∑ÿßŸÇÿ© ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿ•ŸÑŸâ ÿ£ŸÇÿµŸâ ÿ≠ÿØŸàÿØŸáÿß.\n\nÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ®ÿ±ŸäÿØ ŸÉÿßŸÅŸç.\n\nŸáŸÑ ÿ™ÿ±ŸäÿØ ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ©ÿü",
                        warningConfirm: "ŸÖÿ™ÿßÿ®ÿπÿ©",
                        warningCancel: "ÿ•ŸÑÿ∫ÿßÿ°"
                    },
                    zh: {
                        mainTitle: "Ë∂ÖÈáçÂûãGPUÂéãÂäõÊµãËØï",
                        subTitle: "UltimateÁâà - ÂÖºÂÆπÊâÄÊúâÊòæÂç°",
                        testSelectionTitle: "ÊµãËØïÈÄâÊã©",
                        test1Name: "ÊûÅÈôêÂÖâÁ∫øËøΩË∏™",
                        test2Name: "‰ΩìÁßØÈõæ",
                        test3Name: "Á≤íÂ≠êÁâ©ÁêÜ",
                        test4Name: "Á∫πÁêÜÊµÅÂºè‰º†Ëæì",
                        test5Name: "ÊûÅÈôê‰ΩìÁßØÁùÄËâ≤Âô®",
                        settingsTitle: "ËÆæÁΩÆ",
                        qualityLabel: "ÂõæÂΩ¢Ë¥®Èáè:",
                        pressureLabel: "ÂéãÂäõÁ≠âÁ∫ß:",
                        resolutionLabel: "FPSÈôêÂà∂:",
                        fpsLabel: "FPS",
                        startBtnText: "ÂºÄÂßãÊµãËØï",
                        stopBtnText: "ÂÅúÊ≠¢ÊµãËØï",
                        unlockBtnText: "Ëß£ÈîÅFPS",
                        resetBtnText: "ÈáçÁΩÆ",
                        resultsTitle: "ÊµãËØïÁªìÊûú",
                        score1Label: "ÊÄª‰ΩìÂæóÂàÜ",
                        score2Label: "Âπ≥ÂùáFPS",
                        score3Label: "Á®≥ÂÆöÊÄß",
                        detail1Label: "ÊµãËØïÊó∂Èïø:",
                        detail2Label: "ÊúÄÈ´òFPS:",
                        detail3Label: "ÊúÄ‰ΩéFPS:",
                        detail4Label: "ÊÄßËÉΩÁ≠âÁ∫ß:",
                        footerText: "Ë∂ÖÈáçÂûãGPUÂéãÂäõÊµãËØï v20.0 UltimateÁâà | ÂÖºÂÆπÊâÄÊúâÊòæÂç°",
                        warningTitle: "‚ö†Ô∏è Ë≠¶Âëä",
                        warningText: "ËøôÊòØÊûÅÁ´ØGPUÂéãÂäõÊµãËØïÔºÅ\n\nÊ≠§ÊµãËØïÂ∞ÜÊääÊÇ®ÁöÑÊòæÂç°Êé®Âà∞ÊûÅÈôê„ÄÇ\n\nËØ∑Á°Æ‰øùÊÇ®ÁöÑÂÜ∑Âç¥Á≥ªÁªüË∂≥Â§ü„ÄÇ\n\nÊÇ®Ë¶ÅÁªßÁª≠ÂêóÔºü",
                        warningConfirm: "ÁªßÁª≠",
                        warningCancel: "ÂèñÊ∂à"
                    },
                    ru: {
                        mainTitle: "–°–≤–µ—Ä—Ö—Ç—è–∂–µ–ª—ã–π —Å—Ç—Ä–µ—Å—Å-—Ç–µ—Å—Ç GPU",
                        subTitle: "Ultimate –≤–µ—Ä—Å–∏—è - –°–æ–≤–º–µ—Å—Ç–∏–º–æ —Å–æ –≤—Å–µ–º–∏ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–∞–º–∏",
                        testSelectionTitle: "–í—ã–±–æ—Ä —Ç–µ—Å—Ç–∞",
                        test1Name: "–≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –ª—É—á–µ–π",
                        test2Name: "–û–±—ä–µ–º–Ω—ã–π —Ç—É–º–∞–Ω",
                        test3Name: "–§–∏–∑–∏–∫–∞ —á–∞—Å—Ç–∏—Ü",
                        test4Name: "–ü–æ—Ç–æ–∫–æ–≤–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ —Ç–µ–∫—Å—Ç—É—Ä",
                        test5Name: "–≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–π Volume Shader",
                        settingsTitle: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                        qualityLabel: "–ö–∞—á–µ—Å—Ç–≤–æ –≥—Ä–∞—Ñ–∏–∫–∏:",
                        pressureLabel: "–£—Ä–æ–≤–µ–Ω—å –Ω–∞–≥—Ä—É–∑–∫–∏:",
                        resolutionLabel: "–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ FPS:",
                        fpsLabel: "FPS",
                        startBtnText: "–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç",
                        stopBtnText: "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ—Å—Ç",
                        unlockBtnText: "–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å FPS",
                        resetBtnText: "–°–±—Ä–æ—Å",
                        resultsTitle: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞",
                        score1Label: "–û–±—â–∏–π –±–∞–ª–ª",
                        score2Label: "–°—Ä–µ–¥–Ω–∏–π FPS",
                        score3Label: "–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å",
                        detail1Label: "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∞:",
                        detail2Label: "–ú–∞–∫—Å. FPS:",
                        detail3Label: "–ú–∏–Ω. FPS:",
                        detail4Label: "–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:",
                        footerText: "–°–≤–µ—Ä—Ö—Ç—è–∂–µ–ª—ã–π —Å—Ç—Ä–µ—Å—Å-—Ç–µ—Å—Ç GPU v20.0 Ultimate –≤–µ—Ä—Å–∏—è | –°–æ–≤–º–µ—Å—Ç–∏–º–æ —Å–æ –≤—Å–µ–º–∏ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–∞–º–∏",
                        warningTitle: "‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï",
                        warningText: "–≠—Ç–æ –≠–ö–°–¢–†–ï–ú–ê–õ–¨–ù–´–ô —Å—Ç—Ä–µ—Å—Å-—Ç–µ—Å—Ç GPU!\n\n–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±—É–¥–µ—Ç –Ω–∞–≥—Ä—É–∂–∞—Ç—å –≤–∞—à—É –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—É –¥–æ –ø—Ä–µ–¥–µ–ª–∞.\n\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –æ—Ö–ª–∞–∂–¥–µ–Ω–∏—è –∞–¥–µ–∫–≤–∞—Ç–Ω–∞.\n\n–í—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                        warningConfirm: "–ü–†–û–î–û–õ–ñ–ò–¢–¨",
                        warningCancel: "–û–¢–ú–ï–ù–ê"
                    }
                };
                
                this.changeLanguage('en');
            }
            
            changeLanguage(lang) {
                this.state.currentLanguage = lang;
                const t = this.translations[lang];
                
                if (!t) return;
                
                const elements = [
                    'mainTitle', 'subTitle', 'testSelectionTitle',
                    'test1Name', 'test2Name', 'test3Name', 'test4Name', 'test5Name',
                    'settingsTitle', 'qualityLabel', 'pressureLabel', 'resolutionLabel',
                    'fpsLabel',
                    'startBtnText', 'stopBtnText', 'unlockBtnText', 'resetBtnText',
                    'resultsTitle', 'score1Label', 'score2Label', 'score3Label',
                    'detail1Label', 'detail2Label', 'detail3Label', 'detail4Label',
                    'footerText',
                    'warningTitle', 'warningText', 'warningConfirm', 'warningCancel'
                ];
                
                elements.forEach(key => {
                    const element = document.getElementById(key);
                    if (element && t[key]) {
                        element.textContent = t[key];
                    }
                });
                
                this.updateSettingsDisplay();
                this.updateTestTitle();
                if (this.state.results.overallScore > 0) {
                    this.updateResultsDisplay();
                }
            }
            
            updateSettingsDisplay() {
                document.getElementById('qualityValue').textContent = `${this.state.settings.qualityLevel}%`;
                document.getElementById('pressureValue').textContent = `${this.state.settings.pressureLevel}%`;
                document.getElementById('resolutionValue').textContent = `${this.state.settings.fpsLimit}`;
            }
            
            // ANIMATION FUNCTIONS
            
            startIdleAnimation() {
                if (this.idleAnimationId) {
                    cancelAnimationFrame(this.idleAnimationId);
                }
                
                const animate = () => {
                    if (this.state.isRunning || !this.state.idleAnimationActive) {
                        return;
                    }
                    
                    const now = performance.now();
                    if (this.state.lastIdleFrameTime) {
                        const delta = now - this.state.lastIdleFrameTime;
                        if (delta > 0) {
                            const currentFPS = 1000 / delta;
                            this.state.fpsSmoothing.push(currentFPS);
                            if (this.state.fpsSmoothing.length > this.state.fpsSmoothingLength) {
                                this.state.fpsSmoothing.shift();
                            }
                            
                            const smoothedFPS = this.getSmoothedFPS();
                            this.state.fps = Math.round(smoothedFPS);
                            document.getElementById('fpsValue').textContent = this.state.fps;
                            document.getElementById('fullscreenFpsValue').textContent = this.state.fps;
                            this.updateFPSColor();
                            this.updateFullscreenFPSColor();
                        }
                    }
                    this.state.lastIdleFrameTime = now;
                    
                    this.renderEnhancedIdleScene(now);
                    
                    this.idleAnimationId = requestAnimationFrame(animate);
                };
                
                this.state.idleAnimationActive = true;
                this.idleAnimationId = requestAnimationFrame(animate);
            }
            
            getSmoothedFPS() {
                if (this.state.fpsSmoothing.length === 0) return 60;
                
                let total = 0;
                let weightSum = 0;
                
                for (let i = 0; i < this.state.fpsSmoothing.length; i++) {
                    const weight = 1 - (i / (this.state.fpsSmoothing.length * 2));
                    total += this.state.fpsSmoothing[i] * weight;
                    weightSum += weight;
                }
                
                return total / weightSum;
            }
            
            renderEnhancedIdleScene(currentTime) {
                this.clearCanvas();
                
                const time = currentTime / 1000;
                
                // Complex background gradient
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#000011');
                gradient.addColorStop(0.3, '#05051a');
                gradient.addColorStop(0.5, '#0a0a2a');
                gradient.addColorStop(0.7, '#05051a');
                gradient.addColorStop(1, '#000011');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Animate background particles
                this.state.bgParticles.forEach(particle => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.rotation += particle.rotationSpeed;
                    
                    if (particle.x < -10) particle.x = this.canvas.width + 10;
                    if (particle.x > this.canvas.width + 10) particle.x = -10;
                    if (particle.y < -10) particle.y = this.canvas.height + 10;
                    if (particle.y > this.canvas.height + 10) particle.y = -10;
                    
                    this.ctx.save();
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    
                    if (particle.size > 2) {
                        this.ctx.ellipse(0, 0, particle.size, particle.size * 0.7, 0, 0, Math.PI * 2);
                    } else {
                        this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                    }
                    
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Enhanced moving grid
                this.ctx.strokeStyle = 'rgba(0, 100, 255, 0.15)';
                this.ctx.lineWidth = 1.5;
                
                const gridSize = 80;
                const offsetX = (time * 40) % gridSize;
                const offsetY = (time * 30) % gridSize;
                
                for (let x = -gridSize + offsetX; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = -gridSize + offsetY; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // Enhanced moving dots
                for (let i = 0; i < 50; i++) {
                    const x = (time * 60 + i * 30) % this.canvas.width;
                    const y = this.canvas.height / 2 + Math.sin(time * 1.2 + i * 0.4) * 200;
                    const size = 4 + Math.sin(time * 2.5 + i) * 3;
                    
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size * 4);
                    gradient.addColorStop(0, `rgba(0, ${200 + i * 2}, 255, 0.9)`);
                    gradient.addColorStop(0.7, `rgba(0, ${150 + i * 2}, 255, 0.4)`);
                    gradient.addColorStop(1, `rgba(0, ${150 + i * 2}, 255, 0)`);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size * 4, 0, Math.PI * 2);
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(0, ${220 + i * 2}, 255, 1)`;
                    this.ctx.fill();
                }
                
                // Instruction text
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                this.ctx.font = 'bold 32px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                const instructionText = this.state.currentLanguage === 'fa' ? 
                    '€å⁄© ÿ™ÿ≥ÿ™ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØŸá Ÿà "ÿ¥ÿ±Ÿàÿπ ÿ™ÿ≥ÿ™" ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ' :
                    this.state.currentLanguage === 'ar' ? 'ÿßÿÆÿ™ÿ± ÿßÿÆÿ™ÿ®ÿßÿ± Ÿàÿßÿ∂ÿ∫ÿ∑ "ÿ®ÿØÿ° ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±"' :
                    this.state.currentLanguage === 'zh' ? 'ÈÄâÊã©‰∏Ä‰∏™ÊµãËØïÂπ∂ÁÇπÂáª"ÂºÄÂßãÊµãËØï"' :
                    this.state.currentLanguage === 'ru' ? '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ—Å—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç"' :
                    'Select a test and click "Start Test"';
                
                this.ctx.fillText(instructionText, this.canvas.width / 2, this.canvas.height / 2);
                
                this.ctx.fillStyle = 'rgba(0, 255, 204, 0.2)';
                this.ctx.font = 'bold 60px Arial';
                this.ctx.fillText('GPU STRESS TEST PRO', this.canvas.width / 2, this.canvas.height / 2 + 80);
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.fillText('ULTIMATE EDITION', this.canvas.width / 2, this.canvas.height / 2 + 130);
            }
            
            stopIdleAnimation() {
                this.state.idleAnimationActive = false;
                if (this.idleAnimationId) {
                    cancelAnimationFrame(this.idleAnimationId);
                    this.idleAnimationId = null;
                }
            }
            
            // TEST FUNCTIONS
            
            startTest() {
                if (this.state.isRunning) {
                    this.showToast('Test is already running!');
                    return;
                }
                
                console.log(`Starting ${this.state.currentTest} test`);
                
                this.stopIdleAnimation();
                this.state.isRunning = true;
                this.state.frameCount = 0;
                this.state.startTime = performance.now();
                this.state.lastFrameTime = 0;
                this.state.fpsHistory = [];
                this.state.testDuration = 0;
                this.state.fpsSmoothing = [];
                
                this.configureUltraHeavyTest();
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('resetBtn').disabled = true;
                
                this.hideResults();
                this.startTestAnimation();
                
                console.log(`‚úÖ ${this.state.currentTest} test started`);
                this.showToast(`${this.getTestName(this.state.currentTest)} test started`);
            }
            
            configureUltraHeavyTest() {
                const qualityMultiplier = this.state.settings.qualityLevel / 100;
                const pressureMultiplier = this.state.settings.pressureLevel / 100;
                
                this.state.sceneObjects = [];
                this.state.particles = [];
                this.state.fogData = null;
                this.state.textures = [];
                this.state.volumeShaders = [];
                
                switch(this.state.currentTest) {
                    case 'raytrace':
                        this.configureRayTracingUltraHeavy(qualityMultiplier, pressureMultiplier);
                        break;
                    case 'volumetric':
                        this.configureVolumetricUltraHeavy(qualityMultiplier, pressureMultiplier);
                        break;
                    case 'particles':
                        this.configureParticlesUltraHeavy(qualityMultiplier, pressureMultiplier);
                        break;
                    case 'texture':
                        this.configureTexturesUltraHeavy(qualityMultiplier, pressureMultiplier);
                        break;
                    case 'volume_shader':
                        this.configureVolumeShadersModerate(qualityMultiplier, pressureMultiplier);
                        break;
                }
            }
            
            configureRayTracingUltraHeavy(qualityMultiplier, pressureMultiplier) {
                const objectCount = Math.floor(500000 * pressureMultiplier);
                const lightCount = Math.floor(25 * qualityMultiplier);
                
                console.log(`Extreme Ray Tracing: Creating ${objectCount} objects and ${lightCount} lights`);
                
                for (let i = 0; i < objectCount; i++) {
                    this.state.sceneObjects.push({
                        type: 'sphere',
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 5 + Math.random() * 30,
                        color: this.getRandomColor(),
                        reflection: 0.5 + Math.random() * 0.5,
                        velocity: {
                            x: (Math.random() - 0.5) * 8,
                            y: (Math.random() - 0.5) * 8
                        },
                        glow: Math.random() > 0.5,
                        metallic: Math.random() > 0.4,
                        complexity: Math.floor(3 + Math.random() * 7)
                    });
                }
                
                for (let i = 0; i < lightCount; i++) {
                    this.state.sceneObjects.push({
                        type: 'light',
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 40 + Math.random() * 80,
                        intensity: 200 + Math.random() * 200,
                        color: this.getRandomLightColor(),
                        pulse: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.03,
                        moveX: (Math.random() - 0.5) * 3,
                        moveY: (Math.random() - 0.5) * 3,
                        trails: [],
                        maxTrails: 5 + Math.floor(Math.random() * 10)
                    });
                }
            }
            
            configureVolumetricUltraHeavy(qualityMultiplier, pressureMultiplier) {
                const layers = 8000000; // 8 MILLION LAYERS
                
                console.log(`Volumetric Fog: Creating ${layers} layers`);
                
                this.state.fogData = {
                    time: 0,
                    layers: layers,
                    density: 0.15 + (0.3 * qualityMultiplier),
                    speed: 0.2 + (0.4 * pressureMultiplier),
                    lightCount: 12 + Math.floor(20 * qualityMultiplier),
                    turbulence: 0.2 + (0.5 * pressureMultiplier),
                    colors: [
                        'rgba(60, 100, 255, ALPHA)',
                        'rgba(80, 140, 255, ALPHA)',
                        'rgba(100, 180, 255, ALPHA)',
                        'rgba(120, 200, 255, ALPHA)',
                        'rgba(140, 220, 255, ALPHA)',
                        'rgba(160, 240, 255, ALPHA)',
                        'rgba(180, 220, 255, ALPHA)',
                        'rgba(200, 240, 255, ALPHA)',
                        'rgba(140, 180, 255, ALPHA)',
                        'rgba(100, 140, 255, ALPHA)',
                        'rgba(200, 230, 255, ALPHA)',
                        'rgba(160, 200, 245, ALPHA)'
                    ],
                    waveAmplitude: 100 + (200 * pressureMultiplier),
                    waveFrequency: 0.6 + (1.0 * pressureMultiplier),
                    noiseScale: 0.1 + (0.3 * qualityMultiplier),
                    noiseSpeed: 0.2 + (0.4 * pressureMultiplier)
                };
            }
            
            configureParticlesUltraHeavy(qualityMultiplier, pressureMultiplier) {
                const particleCount = Math.floor(500000 * pressureMultiplier);
                
                console.log(`Particles: Creating ${particleCount} particles`);
                
                for (let i = 0; i < particleCount; i++) {
                    this.state.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        size: 0.3 + Math.random() * 2.0,
                        color: this.getRandomColor(),
                        life: 200 + Math.random() * 300,
                        gravity: 0.12,
                        friction: 0.92,
                        trail: [],
                        maxTrail: 5 + Math.floor(Math.random() * 8),
                        glow: Math.random() > 0.4,
                        attraction: Math.random() > 0.7,
                        attractorX: Math.random() * this.canvas.width,
                        attractorY: Math.random() * this.canvas.height,
                        attractionForce: 0.05 + Math.random() * 0.15,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.1
                    });
                }
            }
            
            configureTexturesUltraHeavy(qualityMultiplier, pressureMultiplier) {
                const textureCount = 2000000;
                
                console.log(`Textures: Creating ${textureCount} textures`);
                
                const colors = this.generateExtremeColors();
                
                for (let i = 0; i < Math.min(2000000, textureCount * pressureMultiplier * qualityMultiplier); i++) {
                    this.state.textures.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: 30 + Math.random() * 150,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        pattern: Math.floor(Math.random() * 15),
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        scale: 0.5 + Math.random() * 1.2,
                        pulse: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.04 + Math.random() * 0.1,
                        glow: Math.random() > 0.1,
                        complexity: Math.floor(4 + Math.random() * 12),
                        noise: Math.random() > 0.3,
                        layers: Math.floor(3 + Math.random() * 10),
                        speed: 0.8 + Math.random() * 2.0,
                        waveAmplitude: 5 + Math.random() * 20,
                        waveFrequency: 0.8 + Math.random() * 3.0,
                        time: Math.random() * Math.PI * 2
                    });
                }
            }
            
            configureVolumeShadersModerate(qualityMultiplier, pressureMultiplier) {
                // ÿß€åÿ¨ÿßÿØ 50 ÿ¥€åÿØÿ± ÿ≠ÿ¨ŸÖ€å ÿ®ÿß ÿ¨ÿ≤ÿ¶€åÿßÿ™ ŸÖÿ™Ÿàÿ≥ÿ∑
                const shaderCount = Math.floor(50 * pressureMultiplier * qualityMultiplier);
                
                console.log(`Volume Shaders: Creating ${shaderCount} shaders (Moderate detail)`);
                
                for (let i = 0; i < shaderCount; i++) {
                    const size = 80 + Math.random() * 160;
                    const color = this.getRandomColor();
                    
                    this.state.volumeShaders.push({
                        id: i,
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: size,
                        color: color,
                        baseColor: color,
                        time: Math.random() * Math.PI * 2,
                        speed: 0.4 + Math.random() * 1.2,
                        layers: 8 + Math.floor(qualityMultiplier * 15),
                        density: 0.5 + Math.random() * 0.7,
                        noise: Math.random() * 3,
                        glow: true,
                        pulse: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.015 + Math.random() * 0.035,
                        moveX: (Math.random() - 0.5) * 2.5,
                        moveY: (Math.random() - 0.5) * 2.5,
                        intensity: 0.8 + Math.random() * 0.4,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.03,
                        waveAmplitude: 10 + Math.random() * 25,
                        waveFrequency: 0.7 + Math.random() * 2.0
                    });
                }
            }
            
            startTestAnimation() {
                const animate = (currentTime) => {
                    if (!this.state.isRunning) return;
                    
                    if (!this.state.startTime) this.state.startTime = currentTime;
                    
                    const deltaTime = currentTime - (this.state.lastFrameTime || currentTime);
                    this.state.lastFrameTime = currentTime;
                    
                    if (deltaTime > 0) {
                        let calculatedFPS = 1000 / deltaTime;
                        
                        this.state.fpsSmoothing.push(calculatedFPS);
                        if (this.state.fpsSmoothing.length > this.state.fpsSmoothingLength) {
                            this.state.fpsSmoothing.shift();
                        }
                        
                        const smoothedFPS = this.getSmoothedFPS();
                        
                        if (!this.state.isUnlocked && this.state.settings.fpsLimit > 0) {
                            const maxFPS = this.state.settings.fpsLimit;
                            if (smoothedFPS > maxFPS) {
                                const waitTime = Math.max(0, 1000/maxFPS - deltaTime);
                                if (waitTime > 0) {
                                    setTimeout(() => {
                                        this.testAnimationId = requestAnimationFrame(animate);
                                    }, waitTime);
                                    return;
                                }
                            }
                        }
                        
                        this.state.fps = Math.round(smoothedFPS);
                        this.state.fpsHistory.push(this.state.fps);
                        if (this.state.fpsHistory.length > 300) this.state.fpsHistory.shift();
                        
                        document.getElementById('fpsValue').textContent = this.state.fps;
                        document.getElementById('fullscreenFpsValue').textContent = this.state.fps;
                        this.updateFPSColor();
                        this.updateFullscreenFPSColor();
                        
                        this.state.results.minFPS = Math.min(this.state.results.minFPS, this.state.fps);
                        this.state.results.maxFPS = Math.max(this.state.results.maxFPS, this.state.fps);
                    }
                    
                    this.renderUltraHeavyTest(deltaTime);
                    
                    this.state.frameCount++;
                    this.state.testDuration = (currentTime - this.state.startTime) / 1000;
                    
                    this.testAnimationId = requestAnimationFrame(animate);
                };
                
                this.testAnimationId = requestAnimationFrame(animate);
            }
            
            renderUltraHeavyTest(deltaTime) {
                this.clearCanvas();
                
                switch(this.state.currentTest) {
                    case 'raytrace':
                        this.renderRayTracingUltraHeavy(deltaTime);
                        break;
                    case 'volumetric':
                        this.renderVolumetricUltraHeavy(deltaTime);
                        break;
                    case 'particles':
                        this.renderParticlesUltraHeavy(deltaTime);
                        break;
                    case 'texture':
                        this.renderTexturesUltraHeavy(deltaTime);
                        break;
                    case 'volume_shader':
                        this.renderVolumeShadersModerate(deltaTime);
                        break;
                }
            }
            
            renderRayTracingUltraHeavy(deltaTime) {
                const timeFactor = deltaTime / 16;
                
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#000008');
                gradient.addColorStop(0.3, '#0a0a1a');
                gradient.addColorStop(0.7, '#080825');
                gradient.addColorStop(1, '#000008');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.renderAdvancedGrid(timeFactor);
                
                const renderCount = Math.min(50000, this.state.sceneObjects.length);
                
                for (let i = 0; i < renderCount; i++) {
                    const obj = this.state.sceneObjects[i];
                    
                    if (obj.type === 'sphere') {
                        obj.x += obj.velocity.x * timeFactor;
                        obj.y += obj.velocity.y * timeFactor;
                        
                        if (obj.complexity > 5) {
                            obj.x += Math.sin(this.state.testDuration * 0.5 + i * 0.1) * 2;
                            obj.y += Math.cos(this.state.testDuration * 0.3 + i * 0.15) * 2;
                        }
                        
                        if (obj.x < obj.radius || obj.x > this.canvas.width - obj.radius) {
                            obj.velocity.x *= -0.95;
                            obj.x = Math.max(obj.radius, Math.min(this.canvas.width - obj.radius, obj.x));
                        }
                        if (obj.y < obj.radius || obj.y > this.canvas.height - obj.radius) {
                            obj.velocity.y *= -0.95;
                            obj.y = Math.max(obj.radius, Math.min(this.canvas.height - obj.radius, obj.y));
                        }
                        
                        const sphereGradient = this.ctx.createRadialGradient(
                            obj.x - obj.radius/4, 
                            obj.y - obj.radius/4, 
                            0,
                            obj.x, 
                            obj.y, 
                            obj.radius
                        );
                        
                        sphereGradient.addColorStop(0, this.lightenColor(obj.color, 0.5));
                        sphereGradient.addColorStop(0.3, this.lightenColor(obj.color, 0.2));
                        sphereGradient.addColorStop(0.6, obj.color);
                        sphereGradient.addColorStop(1, this.darkenColor(obj.color, 0.4));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        this.ctx.fillStyle = sphereGradient;
                        this.ctx.fill();
                        
                        if (obj.metallic) {
                            const highlightSize = obj.radius / 3;
                            const highlightGradient = this.ctx.createRadialGradient(
                                obj.x - obj.radius/3, 
                                obj.y - obj.radius/3, 
                                0,
                                obj.x - obj.radius/3, 
                                obj.y - obj.radius/3, 
                                highlightSize
                            );
                            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            highlightGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
                            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            
                            this.ctx.beginPath();
                            this.ctx.arc(obj.x - obj.radius/3, obj.y - obj.radius/3, highlightSize, 0, Math.PI * 2);
                            this.ctx.fillStyle = highlightGradient;
                            this.ctx.fill();
                        }
                        
                        if (obj.reflection > 0.3) {
                            const reflectionSize = obj.radius * 3;
                            const reflectionGradient = this.ctx.createRadialGradient(
                                obj.x, obj.y, obj.radius * 1.1,
                                obj.x, obj.y, reflectionSize
                            );
                            reflectionGradient.addColorStop(0, this.adjustAlpha(obj.color, 0.3 * obj.reflection));
                            reflectionGradient.addColorStop(0.5, this.adjustAlpha(obj.color, 0.1 * obj.reflection));
                            reflectionGradient.addColorStop(1, this.adjustAlpha(obj.color, 0));
                            
                            this.ctx.beginPath();
                            this.ctx.arc(obj.x, obj.y, reflectionSize, 0, Math.PI * 2);
                            this.ctx.fillStyle = reflectionGradient;
                            this.ctx.fill();
                        }
                        
                        if (obj.glow) {
                            const glowSize = obj.radius * 4;
                            const glowGradient = this.ctx.createRadialGradient(
                                obj.x, obj.y, obj.radius,
                                obj.x, obj.y, glowSize
                            );
                            glowGradient.addColorStop(0, this.adjustAlpha(obj.color, 0.6));
                            glowGradient.addColorStop(0.3, this.adjustAlpha(obj.color, 0.3));
                            glowGradient.addColorStop(0.6, this.adjustAlpha(obj.color, 0.1));
                            glowGradient.addColorStop(1, this.adjustAlpha(obj.color, 0));
                            
                            this.ctx.beginPath();
                            this.ctx.arc(obj.x, obj.y, glowSize, 0, Math.PI * 2);
                            this.ctx.fillStyle = glowGradient;
                            this.ctx.fill();
                        }
                        
                    } else if (obj.type === 'light') {
                        obj.x += obj.moveX * timeFactor;
                        obj.y += obj.moveY * timeFactor;
                        obj.pulse += obj.speed * timeFactor;
                        
                        obj.trails.push({x: obj.x, y: obj.y});
                        if (obj.trails.length > obj.maxTrails) {
                            obj.trails.shift();
                        }
                        
                        if (obj.x < obj.radius || obj.x > this.canvas.width - obj.radius) {
                            obj.moveX *= -0.9;
                            obj.x = Math.max(obj.radius, Math.min(this.canvas.width - obj.radius, obj.x));
                        }
                        if (obj.y < obj.radius || obj.y > this.canvas.height - obj.radius) {
                            obj.moveY *= -0.9;
                            obj.y = Math.max(obj.radius, Math.min(this.canvas.height - obj.radius, obj.y));
                        }
                        
                        if (obj.trails.length > 1) {
                            this.ctx.strokeStyle = this.adjustAlpha(obj.color, 0.15);
                            this.ctx.lineWidth = 15;
                            this.ctx.lineCap = 'round';
                            this.ctx.lineJoin = 'round';
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(obj.trails[0].x, obj.trails[0].y);
                            
                            for (let j = 1; j < obj.trails.length; j++) {
                                this.ctx.lineTo(obj.trails[j].x, obj.trails[j].y);
                            }
                            
                            this.ctx.stroke();
                        }
                        
                        const pulseFactor = 0.5 + Math.sin(obj.pulse) * 0.5;
                        const currentRadius = obj.radius * pulseFactor;
                        
                        const lightGradient = this.ctx.createRadialGradient(
                            obj.x, obj.y, 0,
                            obj.x, obj.y, currentRadius * 2.5
                        );
                        lightGradient.addColorStop(0, obj.color);
                        lightGradient.addColorStop(0.2, this.adjustAlpha(obj.color, 0.9));
                        lightGradient.addColorStop(0.5, this.adjustAlpha(obj.color, 0.7));
                        lightGradient.addColorStop(1, this.adjustAlpha(obj.color, 0));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, currentRadius * 2.5, 0, Math.PI * 2);
                        this.ctx.fillStyle = lightGradient;
                        this.ctx.fill();
                        
                        const coreGradient = this.ctx.createRadialGradient(
                            obj.x, obj.y, 0,
                            obj.x, obj.y, currentRadius
                        );
                        coreGradient.addColorStop(0, '#ffffff');
                        coreGradient.addColorStop(0.3, this.lightenColor(obj.color, 0.9));
                        coreGradient.addColorStop(0.8, this.adjustAlpha(obj.color, 0.9));
                        coreGradient.addColorStop(1, this.adjustAlpha(obj.color, 0));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, currentRadius, 0, Math.PI * 2);
                        this.ctx.fillStyle = coreGradient;
                        this.ctx.fill();
                    }
                }
            }
            
            renderAdvancedGrid(timeFactor) {
                const gridTime = this.state.testDuration;
                
                this.ctx.strokeStyle = 'rgba(0, 150, 255, 0.15)';
                this.ctx.lineWidth = 0.5;
                
                const gridSize = 80;
                const offsetX = (Math.sin(gridTime * 0.3) * 50 + gridTime * 40) % gridSize;
                const offsetY = (Math.cos(gridTime * 0.2) * 40 + gridTime * 30) % gridSize;
                
                for (let x = -gridSize + offsetX; x < this.canvas.width + gridSize; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    
                    this.ctx.moveTo(x - 20, 0);
                    this.ctx.lineTo(x + 20, this.canvas.height);
                    
                    this.ctx.stroke();
                }
                
                for (let y = -gridSize + offsetY; y < this.canvas.height + gridSize; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    
                    this.ctx.moveTo(0, y - 20);
                    this.ctx.lineTo(this.canvas.width, y + 20);
                    
                    this.ctx.stroke();
                }
            }
            
            renderVolumetricUltraHeavy(deltaTime) {
                if (!this.state.fogData) return;
                
                const timeFactor = deltaTime / 16;
                this.state.fogData.time += this.state.fogData.speed * timeFactor / 60;
                
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#000008');
                gradient.addColorStop(0.4, '#050515');
                gradient.addColorStop(0.6, '#0a0a1a');
                gradient.addColorStop(1, '#000008');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const renderLayers = Math.min(2000, this.state.fogData.layers / 4);
                const layerHeight = this.canvas.height / renderLayers;
                
                for (let i = 0; i < renderLayers; i++) {
                    const y = i * layerHeight;
                    const progress = i / renderLayers;
                    
                    const waveX1 = Math.sin(this.state.fogData.time * 0.8 + i * 0.02) * 
                                 this.state.fogData.waveAmplitude * 
                                 (1 - progress) * 2.0;
                    const waveX2 = Math.cos(this.state.fogData.time * 0.5 + i * 0.015) * 
                                 this.state.fogData.waveAmplitude * 0.7 * 
                                 (1 - progress);
                    
                    const waveY1 = Math.sin(this.state.fogData.time * 0.4 + i * 0.025) * 
                                 this.state.fogData.waveAmplitude * 0.4;
                    const waveY2 = Math.cos(this.state.fogData.time * 0.6 + i * 0.03) * 
                                 this.state.fogData.waveAmplitude * 0.3;
                    
                    const totalWaveX = waveX1 + waveX2;
                    const totalWaveY = waveY1 + waveY2;
                    
                    const alpha = this.state.fogData.density * (1 - progress) * (0.6 + Math.sin(progress * Math.PI) * 0.4);
                    
                    const noise = Math.sin(this.state.fogData.time * this.state.fogData.noiseSpeed + i * 0.05) * 
                                this.state.fogData.noiseScale * 
                                this.canvas.width * (1 - progress);
                    
                    const colorIndex = Math.floor((progress * 1.5) % this.state.fogData.colors.length);
                    const colorStr = this.state.fogData.colors[colorIndex % this.state.fogData.colors.length]
                        .replace('ALPHA', alpha * 0.8);
                    
                    const turbulence = Math.sin(this.state.fogData.time * 1.2 + i * 0.08) * 
                                     this.state.fogData.turbulence * 
                                     this.canvas.width * 0.25 * (1 - progress);
                    
                    this.ctx.fillStyle = colorStr;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-turbulence - noise, y);
                    
                    this.ctx.bezierCurveTo(
                        this.canvas.width/4 + totalWaveX, y + totalWaveY,
                        this.canvas.width*3/4 + totalWaveX, y - totalWaveY * 1.8,
                        this.canvas.width + turbulence + noise, y
                    );
                    
                    this.ctx.lineTo(this.canvas.width + turbulence + noise, y + layerHeight + 3);
                    
                    this.ctx.bezierCurveTo(
                        this.canvas.width*3/4 + totalWaveX, y + layerHeight + 3 - totalWaveY * 1.8,
                        this.canvas.width/4 + totalWaveX, y + layerHeight + 3 + totalWaveY,
                        -turbulence - noise, y + layerHeight + 3
                    );
                    
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                for (let i = 0; i < Math.min(15, this.state.fogData.lightCount); i++) {
                    const lightX = this.canvas.width/2 + 
                                  Math.sin(this.state.fogData.time * 0.25 + i * 1.5) * 
                                  this.canvas.width * 0.45 +
                                  Math.cos(this.state.fogData.time * 0.15 + i * 0.8) * 
                                  this.canvas.width * 0.2;
                                  
                    const lightY = this.canvas.height/2 + 
                                  Math.cos(this.state.fogData.time * 0.2 + i * 1.2) * 
                                  this.canvas.height * 0.35 +
                                  Math.sin(this.state.fogData.time * 0.1 + i * 0.6) * 
                                  this.canvas.height * 0.25;
                    
                    const pulse = 0.6 + Math.sin(this.state.fogData.time * 0.5 + i * 2) * 0.4;
                    
                    const outerGlowSize = 300 * pulse;
                    const outerGradient = this.ctx.createRadialGradient(
                        lightX, lightY, 0,
                        lightX, lightY, outerGlowSize
                    );
                    
                    outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    outerGradient.addColorStop(0.1, 'rgba(230, 240, 255, 0.7)');
                    outerGradient.addColorStop(0.3, 'rgba(200, 220, 255, 0.4)');
                    outerGradient.addColorStop(0.6, 'rgba(170, 200, 255, 0.2)');
                    outerGradient.addColorStop(1, 'rgba(150, 180, 255, 0)');
                    
                    this.ctx.beginPath();
                    this.ctx.arc(lightX, lightY, outerGlowSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = outerGradient;
                    this.ctx.fill();
                    
                    const middleGlowSize = 150 * pulse;
                    const middleGradient = this.ctx.createRadialGradient(
                        lightX, lightY, 0,
                        lightX, lightY, middleGlowSize
                    );
                    
                    middleGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    middleGradient.addColorStop(0.2, 'rgba(240, 245, 255, 0.9)');
                    middleGradient.addColorStop(0.5, 'rgba(220, 230, 255, 0.6)');
                    middleGradient.addColorStop(0.8, 'rgba(200, 215, 255, 0.3)');
                    middleGradient.addColorStop(1, 'rgba(180, 200, 255, 0)');
                    
                    this.ctx.beginPath();
                    this.ctx.arc(lightX, lightY, middleGlowSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = middleGradient;
                    this.ctx.fill();
                    
                    const coreSize = 80 * pulse;
                    const coreGradient = this.ctx.createRadialGradient(
                        lightX, lightY, 0,
                        lightX, lightY, coreSize
                    );
                    
                    coreGradient.addColorStop(0, '#ffffff');
                    coreGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
                    coreGradient.addColorStop(0.7, 'rgba(240, 245, 255, 0.7)');
                    coreGradient.addColorStop(1, 'rgba(220, 230, 255, 0)');
                    
                    this.ctx.beginPath();
                    this.ctx.arc(lightX, lightY, coreSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    this.ctx.lineWidth = 2;
                    this.ctx.lineCap = 'round';
                    
                    const rayCount = 12;
                    for (let r = 0; r < rayCount; r++) {
                        const angle = (r / rayCount) * Math.PI * 2 + this.state.fogData.time * 0.1;
                        const rayLength = 400 * pulse;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(lightX, lightY);
                        this.ctx.lineTo(
                            lightX + Math.cos(angle) * rayLength,
                            lightY + Math.sin(angle) * rayLength
                        );
                        this.ctx.stroke();
                    }
                }
            }
            
            renderParticlesUltraHeavy(deltaTime) {
                const timeFactor = deltaTime / 16;
                
                const bgGradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                bgGradient.addColorStop(0, 'rgba(0, 0, 15, 0.08)');
                bgGradient.addColorStop(0.5, 'rgba(5, 5, 25, 0.06)');
                bgGradient.addColorStop(1, 'rgba(0, 0, 15, 0.08)');
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const renderCount = Math.min(50000, this.state.particles.length);
                
                for (let i = 0; i < renderCount; i++) {
                    const particle = this.state.particles[i];
                    
                    particle.vx *= particle.friction;
                    particle.vy *= particle.friction;
                    particle.vy += particle.gravity;
                    
                    if (particle.attraction) {
                        const dx = particle.attractorX - particle.x;
                        const dy = particle.attractorY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 10) {
                            particle.vx += (dx / distance) * particle.attractionForce;
                            particle.vy += (dy / distance) * particle.attractionForce;
                        }
                    }
                    
                    particle.rotation += particle.rotationSpeed * timeFactor;
                    
                    particle.x += particle.vx * timeFactor;
                    particle.y += particle.vy * timeFactor;
                    
                    particle.life--;
                    
                    if (particle.life <= 0 || 
                        particle.x < -200 || particle.x > this.canvas.width + 200 ||
                        particle.y < -200 || particle.y > this.canvas.height + 200) {
                        particle.x = Math.random() * this.canvas.width;
                        particle.y = Math.random() * this.canvas.height;
                        particle.vx = (Math.random() - 0.5) * 12;
                        particle.vy = (Math.random() - 0.5) * 12;
                        particle.life = 300 + Math.random() * 400;
                        particle.trail = [];
                        particle.color = this.getRandomColor();
                        particle.attractorX = Math.random() * this.canvas.width;
                        particle.attractorY = Math.random() * this.canvas.height;
                        particle.rotation = Math.random() * Math.PI * 2;
                    }
                    
                    particle.trail.push({
                        x: particle.x, 
                        y: particle.y,
                        size: particle.size,
                        life: particle.life
                    });
                    if (particle.trail.length > particle.maxTrail) {
                        particle.trail.shift();
                    }
                    
                    if (particle.trail.length > 1) {
                        this.ctx.strokeStyle = this.adjustAlpha(particle.color, 0.3);
                        this.ctx.lineWidth = particle.size * 3;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
                        
                        for (let j = 1; j < particle.trail.length; j++) {
                            const trailParticle = particle.trail[j];
                            this.ctx.lineTo(trailParticle.x, trailParticle.y);
                        }
                        
                        this.ctx.stroke();
                    }
                    
                    const particleSize = particle.size * (0.8 + Math.sin(particle.rotation) * 0.2);
                    const particleGradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particleSize * 3
                    );
                    
                    particleGradient.addColorStop(0, particle.color);
                    particleGradient.addColorStop(0.4, this.adjustAlpha(particle.color, 0.9));
                    particleGradient.addColorStop(0.8, this.adjustAlpha(particle.color, 0.6));
                    particleGradient.addColorStop(1, this.adjustAlpha(particle.color, 0));
                    
                    this.ctx.save();
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    this.ctx.beginPath();
                    if (particle.glow && particle.life % 7 === 0) {
                        const spikes = 5 + Math.floor(particle.life % 5);
                        const outerRadius = particleSize * 3;
                        const innerRadius = particleSize * 1.5;
                        
                        for (let j = 0; j < spikes * 2; j++) {
                            const radius = j % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (j * Math.PI) / spikes;
                            
                            if (j === 0) {
                                this.ctx.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                            } else {
                                this.ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                            }
                        }
                        
                        this.ctx.closePath();
                    } else {
                        this.ctx.arc(0, 0, particleSize * 3, 0, Math.PI * 2);
                    }
                    
                    this.ctx.fillStyle = particleGradient;
                    this.ctx.fill();
                    this.ctx.restore();
                    
                    const coreGradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particleSize * 1.5
                    );
                    
                    coreGradient.addColorStop(0, '#ffffff');
                    coreGradient.addColorStop(0.3, this.lightenColor(particle.color, 0.8));
                    coreGradient.addColorStop(0.7, particle.color);
                    coreGradient.addColorStop(1, this.adjustAlpha(particle.color, 0.6));
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particleSize * 1.5, 0, Math.PI * 2);
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.fill();
                    
                    if (particle.glow) {
                        const glowGradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, particleSize * 3,
                            particle.x, particle.y, particleSize * 7
                        );
                        glowGradient.addColorStop(0, this.adjustAlpha(particle.color, 0.4));
                        glowGradient.addColorStop(0.5, this.adjustAlpha(particle.color, 0.2));
                        glowGradient.addColorStop(1, this.adjustAlpha(particle.color, 0));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particleSize * 7, 0, Math.PI * 2);
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.fill();
                    }
                }
            }
            
            renderTexturesUltraHeavy(deltaTime) {
                const timeFactor = deltaTime / 16;
                
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width * 2, this.canvas.height * 2);
                gradient.addColorStop(0, '#000011');
                gradient.addColorStop(0.25, '#0a0a1a');
                gradient.addColorStop(0.5, '#050515');
                gradient.addColorStop(0.75, '#0a0a1a');
                gradient.addColorStop(1, '#000011');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const renderCount = Math.min(50000, this.state.textures.length);
                
                for (let i = 0; i < renderCount; i++) {
                    const texture = this.state.textures[i];
                    
                    texture.time += 0.01 * timeFactor * texture.speed;
                    texture.rotation += texture.rotationSpeed * timeFactor * texture.speed;
                    texture.pulse += texture.pulseSpeed * timeFactor * texture.speed;
                    
                    texture.x += Math.sin(texture.time * texture.waveFrequency) * texture.waveAmplitude * 0.1;
                    texture.y += Math.cos(texture.time * texture.waveFrequency * 0.7) * texture.waveAmplitude * 0.1;
                    
                    texture.x += Math.sin(texture.time * 0.3) * 1.5 * texture.speed;
                    texture.y += Math.cos(texture.time * 0.25) * 1.5 * texture.speed;
                    
                    if (texture.x < -texture.size * 2 || texture.x > this.canvas.width + texture.size * 2) {
                        texture.x = Math.random() * this.canvas.width;
                    }
                    if (texture.y < -texture.size * 2 || texture.y > this.canvas.height + texture.size * 2) {
                        texture.y = Math.random() * this.canvas.height;
                    }
                    
                    const pulseFactor = 0.5 + Math.sin(texture.pulse) * 0.5;
                    const currentSize = texture.size * pulseFactor * texture.scale;
                    
                    this.ctx.save();
                    this.ctx.translate(texture.x, texture.y);
                    this.ctx.rotate(texture.rotation);
                    
                    this.renderUltraComplexTexture(currentSize, texture);
                    
                    if (texture.glow) {
                        const glowSize = currentSize * 4;
                        const glowGradient = this.ctx.createRadialGradient(
                            0, 0, currentSize * 0.6,
                            0, 0, glowSize
                        );
                        glowGradient.addColorStop(0, this.adjustAlpha(texture.color, 0.6));
                        glowGradient.addColorStop(0.3, this.adjustAlpha(texture.color, 0.3));
                        glowGradient.addColorStop(0.6, this.adjustAlpha(texture.color, 0.15));
                        glowGradient.addColorStop(1, this.adjustAlpha(texture.color, 0));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                }
            }
            
            renderUltraComplexTexture(size, texture) {
                this.ctx.fillStyle = texture.color;
                this.ctx.strokeStyle = this.lightenColor(texture.color, 0.7);
                this.ctx.lineWidth = 2;
                
                const layerCount = Math.min(5, texture.layers);
                
                for (let layer = 0; layer < layerCount; layer++) {
                    const layerSize = size * (0.3 + (layer / layerCount) * 0.7);
                    const layerRotation = texture.rotation + layer * 0.2;
                    const layerAlpha = 1.0 - (layer / layerCount) * 0.3;
                    
                    this.ctx.save();
                    this.ctx.rotate(layerRotation);
                    
                    this.ctx.beginPath();
                    
                    if (texture.pattern < 5) {
                        const sides = 3 + texture.pattern % 8;
                        for (let i = 0; i <= sides; i++) {
                            const angle = (i / sides) * Math.PI * 2;
                            const radius = layerSize * (0.7 + Math.sin(angle * 3 + texture.time) * 0.3);
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    } else if (texture.pattern < 10) {
                        const spikes = 5 + texture.pattern % 6;
                        for (let i = 0; i <= spikes * 2; i++) {
                            const angle = (i * Math.PI) / spikes;
                            const radius = i % 2 === 0 ? layerSize : layerSize * 0.5;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    } else {
                        const points = 24;
                        for (let i = 0; i <= points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            const noise = Math.sin(angle * texture.complexity + texture.time) * layerSize * 0.2;
                            const radius = layerSize + noise;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    }
                    
                    this.ctx.closePath();
                    this.ctx.globalAlpha = layerAlpha;
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            renderVolumeShadersModerate(deltaTime) {
                const timeFactor = deltaTime / 16;
                
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const renderCount = Math.min(50, this.state.volumeShaders.length);
                
                // ŸÖÿ™ŸÜ ŸÜŸÖÿß€åÿ¥ ÿ™ÿπÿØÿßÿØ ÿ¥€åÿØÿ±Ÿáÿß
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`50 Volume Shaders (Moderate Detail)`, 20, 40);
                this.ctx.fillText(`Intensity: ${(this.state.settings.pressureLevel)}%`, 20, 70);
                
                for (let i = 0; i < renderCount; i++) {
                    const shader = this.state.volumeShaders[i];
                    
                    shader.time += 0.015 * timeFactor * shader.speed;
                    shader.pulse += shader.pulseSpeed * timeFactor * shader.speed;
                    shader.rotation += shader.rotationSpeed * timeFactor * shader.speed;
                    
                    shader.x += shader.moveX * timeFactor * shader.speed;
                    shader.y += shader.moveY * timeFactor * shader.speed;
                    
                    if (shader.x < shader.size || shader.x > this.canvas.width - shader.size) {
                        shader.moveX *= -1;
                    }
                    if (shader.y < shader.size || shader.y > this.canvas.height - shader.size) {
                        shader.moveY *= -1;
                    }
                    
                    const pulseFactor = 0.6 + Math.sin(shader.pulse) * 0.4;
                    const currentSize = shader.size * pulseFactor;
                    
                    // ÿ±ŸÜÿØÿ± ŸÑÿß€åŸá‚ÄåŸáÿß€å ÿ≠ÿ¨ŸÖ€å (ŸÜÿ≥ÿÆŸá ŸÖÿ™Ÿàÿ≥ÿ∑)
                    const totalLayers = Math.min(20, shader.layers);
                    
                    for (let layer = 0; layer < totalLayers; layer++) {
                        const layerProgress = layer / totalLayers;
                        const layerSize = currentSize * (0.15 + layerProgress * 0.85);
                        const layerAlpha = shader.density * (1 - layerProgress) * 0.2 * shader.intensity;
                        
                        const waveOffset = Math.sin(shader.time * shader.waveFrequency + layer * 0.5) * 
                                         shader.waveAmplitude * (1 - layerProgress);
                        
                        const noiseOffset = Math.cos(shader.time * 0.8 + layer * 0.3) * 
                                          shader.noise * layerProgress * 10;
                        
                        const gradient = this.ctx.createRadialGradient(
                            shader.x, shader.y, 0,
                            shader.x, shader.y, layerSize * 1.3
                        );
                        
                        const baseColor = this.lightenColor(shader.baseColor, layerProgress * 0.3);
                        gradient.addColorStop(0, this.adjustAlpha(baseColor, layerAlpha));
                        gradient.addColorStop(0.4, this.adjustAlpha(shader.color, layerAlpha * 0.6));
                        gradient.addColorStop(0.8, this.adjustAlpha(this.darkenColor(shader.color, 0.2), layerAlpha * 0.3));
                        gradient.addColorStop(1, this.adjustAlpha(shader.color, 0));
                        
                        this.ctx.save();
                        this.ctx.translate(shader.x, shader.y);
                        this.ctx.rotate(shader.rotation + layer * 0.02);
                        
                        this.ctx.beginPath();
                        
                        // ÿß€åÿ¨ÿßÿØ ÿ¥⁄©ŸÑ ŸÖŸàÿ¨‚ÄåÿØÿßÿ± (ŸÜÿ≥ÿÆŸá ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±)
                        const points = 24;
                        for (let j = 0; j <= points; j++) {
                            const angle = (j / points) * Math.PI * 2;
                            const distortion = Math.sin(angle * 5 + shader.time) * waveOffset + 
                                             Math.cos(angle * 3 + shader.time * 0.5) * noiseOffset;
                            const radius = layerSize + distortion;
                            
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (j === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        
                        this.ctx.closePath();
                        this.ctx.fillStyle = gradient;
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                    
                    // Ÿáÿ≥ÿ™Ÿá ŸÖÿ±⁄©ÿ≤€å
                    const coreSize = currentSize * 0.4;
                    const coreGradient = this.ctx.createRadialGradient(
                        shader.x, shader.y, 0,
                        shader.x, shader.y, coreSize
                    );
                    
                    coreGradient.addColorStop(0, '#ffffff');
                    coreGradient.addColorStop(0.2, this.lightenColor(shader.baseColor, 0.7));
                    coreGradient.addColorStop(0.5, this.lightenColor(shader.baseColor, 0.5));
                    coreGradient.addColorStop(1, this.adjustAlpha(shader.baseColor, 0));
                    
                    this.ctx.beginPath();
                    this.ctx.arc(shader.x, shader.y, coreSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.fill();
                    
                    // ÿØÿ±ÿÆÿ¥ÿ¥
                    if (shader.glow) {
                        const glowSize = currentSize * 3.5;
                        const glowGradient = this.ctx.createRadialGradient(
                            shader.x, shader.y, currentSize * 0.7,
                            shader.x, shader.y, glowSize
                        );
                        glowGradient.addColorStop(0, this.adjustAlpha(shader.color, 0.4 * shader.intensity));
                        glowGradient.addColorStop(0.3, this.adjustAlpha(shader.color, 0.2 * shader.intensity));
                        glowGradient.addColorStop(0.6, this.adjustAlpha(shader.color, 0.1 * shader.intensity));
                        glowGradient.addColorStop(1, this.adjustAlpha(shader.color, 0));
                        
                        this.ctx.beginPath();
                        this.ctx.arc(shader.x, shader.y, glowSize, 0, Math.PI * 2);
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.fill();
                    }
                }
            }
            
            stopTest() {
                if (!this.state.isRunning) {
                    this.showToast('No test is running');
                    return;
                }
                
                console.log('Stopping test');
                this.state.isRunning = false;
                
                if (this.testAnimationId) {
                    cancelAnimationFrame(this.testAnimationId);
                    this.testAnimationId = null;
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('resetBtn').disabled = false;
                
                this.calculateResults();
                this.showResults();
                
                this.resetScene();
                this.startIdleAnimation();
                
                this.showToast('Extreme test stopped');
            }
            
            resetAll() {
                console.log('Resetting everything');
                
                if (this.state.isRunning) {
                    this.stopTest();
                }
                
                this.stopIdleAnimation();
                this.clearCanvas();
                this.resetScene();
                this.resetMetrics();
                this.hideResults();
                this.resetUI();
                this.startIdleAnimation();
                
                this.showToast('System reset');
            }
            
            resetScene() {
                this.state.sceneObjects = [];
                this.state.particles = [];
                this.state.fogData = null;
                this.state.textures = [];
                this.state.volumeShaders = [];
            }
            
            clearCanvas() {
                this.ctx.fillStyle = '#000008';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            resetMetrics() {
                this.state.results = {
                    minFPS: 9999,
                    maxFPS: 0,
                    avgFPS: 0,
                    stability: 0,
                    overallScore: 0
                };
            }
            
            resetUI() {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('resetBtn').disabled = false;
                document.getElementById('fpsValue').textContent = '60';
                document.getElementById('fullscreenFpsValue').textContent = '60';
                this.updateFPSColor();
                this.updateFullscreenFPSColor();
            }
            
            hideResults() {
                document.getElementById('resultsPanel').classList.remove('active');
            }
            
            // HELPER FUNCTIONS
            
            getRandomColor() {
                const colors = this.generateExtremeColors();
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            getRandomLightColor() {
                const colors = [
                    '#ffffaa', '#ffaaaa', '#aaffff', '#aaffaa',
                    '#aaaaff', '#ffff88', '#ffaa88', '#88ffff',
                    '#ffaaff', '#aaffaa', '#ffaaaa', '#aaffff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            generateExtremeColors() {
                return [
                    '#FF3366', '#FF6699', '#FF9933', '#FFCC33', '#33FF99',
                    '#33CCCC', '#3399FF', '#3366FF', '#9933FF', '#FF33CC',
                    '#6633FF', '#33CCFF', '#FF0066', '#9933FF', '#3366FF',
                    '#FF6600', '#FF0066', '#9933FF', '#3366FF', '#FFCC00',
                    '#FF6600', '#FF0033', '#00CCFF', '#FF3300', '#FF9900',
                    '#FF0066', '#AA33FF', '#FF33AA', '#33AAFF', '#33FFCC',
                    '#FF88CC', '#FF66AA', '#FF5577', '#FFAA66', '#FFCC66',
                    '#EEFF66', '#99FF66', '#66FF99', '#66FFCC', '#66EEFF'
                ];
            }
            
            lightenColor(color, amount) {
                if (color.startsWith('rgb')) {
                    const rgb = color.match(/\d+/g);
                    if (rgb) {
                        const r = Math.min(255, parseInt(rgb[0]) + amount * 255);
                        const g = Math.min(255, parseInt(rgb[1]) + amount * 255);
                        const b = Math.min(255, parseInt(rgb[2]) + amount * 255);
                        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                    }
                } else if (color.startsWith('#')) {
                    const r = Math.min(255, parseInt(color.slice(1, 3), 16) + amount * 255);
                    const g = Math.min(255, parseInt(color.slice(3, 5), 16) + amount * 255);
                    const b = Math.min(255, parseInt(color.slice(5, 7), 16) + amount * 255);
                    return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                }
                return color;
            }
            
            darkenColor(color, amount) {
                if (color.startsWith('rgb')) {
                    const rgb = color.match(/\d+/g);
                    if (rgb) {
                        const r = Math.max(0, parseInt(rgb[0]) - amount * 255);
                        const g = Math.max(0, parseInt(rgb[1]) - amount * 255);
                        const b = Math.max(0, parseInt(rgb[2]) - amount * 255);
                        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                    }
                } else if (color.startsWith('#')) {
                    const r = Math.max(0, parseInt(color.slice(1, 3), 16) - amount * 255);
                    const g = Math.max(0, parseInt(color.slice(3, 5), 16) - amount * 255);
                    const b = Math.max(0, parseInt(color.slice(5, 7), 16) - amount * 255);
                    return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                }
                return color;
            }
            
            adjustAlpha(color, alpha) {
                if (color.startsWith('rgb(')) {
                    const rgb = color.match(/\d+/g);
                    if (rgb) {
                        return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
                    }
                } else if (color.startsWith('rgba(')) {
                    return color.replace(/[\d.]+\)$/, alpha + ')');
                } else if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                return color;
            }
            
            updateTestTitle() {
                const testNames = {
                    en: {
                        raytrace: 'Extreme Ray Tracing',
                        volumetric: 'Volumetric Fog',
                        particles: 'Particle Physics',
                        texture: 'Texture Streaming',
                        volume_shader: 'Extreme Volume Shader'
                    },
                    fa: {
                        raytrace: 'ÿ±€å‚Äåÿ™ÿ±€åŸÜ⁄Ø ŸÅŸàŸÇ‚ÄåŸæ€åÿ¥ÿ±ŸÅÿ™Ÿá',
                        volumetric: 'ŸÖŸá ÿ≠ÿ¨ŸÖ€å',
                        particles: 'ŸÅ€åÿ≤€å⁄© ÿ∞ÿ±ÿßÿ™',
                        texture: 'ÿßÿ≥ÿ™ÿ±€åŸÖ ÿ®ÿßŸÅÿ™',
                        volume_shader: 'ÿ¥€åÿØÿ± ÿ≠ÿ¨ŸÖ€å ÿ¥ÿØ€åÿØ'
                    },
                    ar: {
                        raytrace: 'ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ£ÿ¥ÿπÿ© ÿßŸÑŸÖÿ™ÿ∑ÿ±ŸÅ',
                        volumetric: 'ÿßŸÑÿ∂ÿ®ÿßÿ® ÿßŸÑÿ≠ÿ¨ŸÖŸä',
                        particles: 'ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑÿ¨ÿ≥ŸäŸÖÿßÿ™',
                        texture: 'ÿØŸÅŸÇ ÿßŸÑŸÇŸàÿßŸÖ',
                        volume_shader: 'ÿ¥ÿßÿØÿ± ÿßŸÑÿ≠ÿ¨ŸÖŸä ÿßŸÑŸÖÿ™ÿ∑ÿ±ŸÅ'
                    },
                    zh: {
                        raytrace: 'ÊûÅÈôêÂÖâÁ∫øËøΩË∏™',
                        volumetric: '‰ΩìÁßØÈõæ',
                        particles: 'Á≤íÂ≠êÁâ©ÁêÜ',
                        texture: 'Á∫πÁêÜÊµÅÂºè‰º†Ëæì',
                        volume_shader: 'ÊûÅÈôê‰ΩìÁßØÁùÄËâ≤Âô®'
                    },
                    ru: {
                        raytrace: '–≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –ª—É—á–µ–π',
                        volumetric: '–û–±—ä–µ–º–Ω—ã–π —Ç—É–º–∞–Ω',
                        particles: '–§–∏–∑–∏–∫–∞ —á–∞—Å—Ç–∏—Ü',
                        texture: '–ü–æ—Ç–æ–∫–æ–≤–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ —Ç–µ–∫—Å—Ç—É—Ä',
                        volume_shader: '–≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–π Volume Shader'
                    }
                };
                
                const lang = this.state.currentLanguage;
                const title = testNames[lang][this.state.currentTest] || testNames.en[this.state.currentTest];
                document.getElementById('currentTestTitle').textContent = title;
            }
            
            getTestName(testKey) {
                const names = {
                    en: {
                        raytrace: "Ray Tracing",
                        volumetric: "Volumetric Fog",
                        particles: "Particle Physics",
                        texture: "Texture Streaming",
                        volume_shader: "Volume Shader"
                    },
                    fa: {
                        raytrace: "ÿ±€å‚Äåÿ™ÿ±€åŸÜ⁄Ø",
                        volumetric: "ŸÖŸá ÿ≠ÿ¨ŸÖ€å",
                        particles: "ŸÅ€åÿ≤€å⁄© ÿ∞ÿ±ÿßÿ™",
                        texture: "ÿßÿ≥ÿ™ÿ±€åŸÖ ÿ®ÿßŸÅÿ™",
                        volume_shader: "ÿ¥€åÿØÿ± ÿ≠ÿ¨ŸÖ€å"
                    },
                    ar: {
                        raytrace: "ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ£ÿ¥ÿπÿ©",
                        volumetric: "ÿßŸÑÿ∂ÿ®ÿßÿ® ÿßŸÑÿ≠ÿ¨ŸÖŸä",
                        particles: "ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑÿ¨ÿ≥ŸäŸÖÿßÿ™",
                        texture: "ÿØŸÅŸÇ ÿßŸÑŸÇŸàÿßŸÖ",
                        volume_shader: "ÿ¥ÿßÿØÿ± ÿßŸÑÿ≠ÿ¨ŸÖŸä"
                    },
                    zh: {
                        raytrace: "ÂÖâÁ∫øËøΩË∏™",
                        volumetric: "‰ΩìÁßØÈõæ",
                        particles: "Á≤íÂ≠êÁâ©ÁêÜ",
                        texture: "Á∫πÁêÜÊµÅÂºè‰º†Ëæì",
                        volume_shader: "‰ΩìÁßØÁùÄËâ≤Âô®"
                    },
                    ru: {
                        raytrace: "–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –ª—É—á–µ–π",
                        volumetric: "–û–±—ä–µ–º–Ω—ã–π —Ç—É–º–∞–Ω",
                        particles: "–§–∏–∑–∏–∫–∞ —á–∞—Å—Ç–∏—Ü",
                        texture: "–ü–æ—Ç–æ–∫–æ–≤–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ —Ç–µ–∫—Å—Ç—É—Ä",
                        volume_shader: "Volume Shader"
                    }
                };
                
                const lang = this.state.currentLanguage;
                return names[lang][testKey] || names.en[testKey];
            }
            
            updateFPSColor() {
                const fpsElement = document.getElementById('fpsValue');
                const fps = this.state.fps;
                
                if (fps >= 300) {
                    fpsElement.style.color = '#00ff00';
                } else if (fps >= 240) {
                    fpsElement.style.color = '#80ff00';
                } else if (fps >= 180) {
                    fpsElement.style.color = '#ffff00';
                } else if (fps >= 120) {
                    fpsElement.style.color = '#ffaa00';
                } else if (fps >= 90) {
                    fpsElement.style.color = '#ff5500';
                } else if (fps >= 60) {
                    fpsElement.style.color = '#ff3300';
                } else {
                    fpsElement.style.color = '#ff0000';
                }
            }
            
            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            toggleUnlock() {
                this.state.isUnlocked = !this.state.isUnlocked;
                const btn = document.getElementById('unlockBtn');
                btn.classList.toggle('active');
                
                const t = this.translations[this.state.currentLanguage];
                if (t) {
                    btn.querySelector('span:last-child').textContent = 
                        this.state.isUnlocked ? t.unlockBtnText : t.unlockBtnText.replace('Unlocked ', 'Lock ');
                }
                
                const messages = {
                    en: this.state.isUnlocked ? "Unlocked FPS activated" : "Unlocked FPS deactivated",
                    fa: this.state.isUnlocked ? "FPS ÿ¢ÿ≤ÿßÿØ ŸÅÿπÿßŸÑ ÿ¥ÿØ" : "FPS ÿ¢ÿ≤ÿßÿØ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØ",
                    ar: this.state.isUnlocked ? "ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ FPS ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇŸäÿØ" : "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÅÿπŸäŸÑ FPS ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇŸäÿØ",
                    zh: this.state.isUnlocked ? "Â∑≤ÊøÄÊ¥ªËß£ÈîÅFPS" : "Â∑≤ÂÅúÁî®Ëß£ÈîÅFPS",
                    ru: this.state.isUnlocked ? "–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ FPS –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞" : "–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ FPS –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞"
                };
                
                this.showToast(messages[this.state.currentLanguage] || 
                    (this.state.isUnlocked ? "Unlocked FPS activated" : "Unlocked FPS deactivated"));
            }
            
            calculateResults() {
                if (this.state.fpsHistory.length === 0) return;
                
                const sum = this.state.fpsHistory.reduce((a, b) => a + b, 0);
                this.state.results.avgFPS = Math.round(sum / this.state.fpsHistory.length);
                
                if (this.state.results.avgFPS > 0) {
                    const sortedFPS = [...this.state.fpsHistory].sort((a, b) => a - b);
                    const onePercentLow = sortedFPS[Math.floor(sortedFPS.length * 0.01)];
                    this.state.results.stability = Math.round((onePercentLow / this.state.results.avgFPS) * 100);
                }
                
                const fpsScore = Math.min(100, (this.state.results.avgFPS / 400) * 100);
                const stabilityScore = this.state.results.stability;
                
                this.state.results.overallScore = Math.round(
                    fpsScore * 0.7 +
                    stabilityScore * 0.3
                );
            }
            
            showResults() {
                document.getElementById('score1Value').textContent = this.state.results.overallScore;
                document.getElementById('score2Value').textContent = Math.round(this.state.results.avgFPS);
                document.getElementById('score3Value').textContent = `${this.state.results.stability}%`;
                
                document.getElementById('detail1Value').textContent = `${this.state.testDuration.toFixed(1)}s`;
                document.getElementById('detail2Value').textContent = Math.round(this.state.results.maxFPS);
                document.getElementById('detail3Value').textContent = Math.round(this.state.results.minFPS);
                
                let level = '';
                const lang = this.state.currentLanguage;
                if (this.state.results.overallScore >= 95) {
                    level = lang === 'fa' ? 'ŸÅŸàŸÇ‚ÄåÿßŸÑÿπÿßÿØŸá' : 
                            lang === 'ar' ? 'ŸÖŸÖÿ™ÿßÿ≤' :
                            lang === 'zh' ? 'ÂçìË∂ä' :
                            lang === 'ru' ? '–û—Ç–ª–∏—á–Ω–æ' : 'Excellent';
                } else if (this.state.results.overallScore >= 85) {
                    level = lang === 'fa' ? 'ÿπÿßŸÑ€å' : 
                            lang === 'ar' ? 'ÿ¨ŸäÿØ ÿ¨ÿØÿßŸã' :
                            lang === 'zh' ? '‰ºòÁßÄ' :
                            lang === 'ru' ? '–•–æ—Ä–æ—à–æ' : 'Great';
                } else if (this.state.results.overallScore >= 70) {
                    level = lang === 'fa' ? 'ÿÆŸàÿ®' : 
                            lang === 'ar' ? 'ÿ¨ŸäÿØ' :
                            lang === 'zh' ? 'ËâØÂ•Ω' :
                            lang === 'ru' ? '–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ' : 'Good';
                } else {
                    level = lang === 'fa' ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' : 
                            lang === 'ar' ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' :
                            lang === 'zh' ? '‰∏≠Á≠â' :
                            lang === 'ru' ? '–°—Ä–µ–¥–Ω–µ' : 'Average';
                }
                
                document.getElementById('detail4Value').textContent = level;
                
                document.getElementById('resultsPanel').classList.add('active');
            }
            
            updateResultsDisplay() {
                const t = this.translations[this.state.currentLanguage];
                if (!t) return;
                
                document.getElementById('resultsTitle').textContent = t.resultsTitle;
                document.getElementById('score1Label').textContent = t.score1Label;
                document.getElementById('score2Label').textContent = t.score2Label;
                document.getElementById('score3Label').textContent = t.score3Label;
                
                for (let i = 1; i <= 4; i++) {
                    const element = document.getElementById(`detail${i}Label`);
                    if (element && t[`detail${i}Label`]) {
                        element.textContent = t[`detail${i}Label`];
                    }
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üì¶ DOM ready - Starting Ultra Heavy GPU Stress Test...');
            window.ultraHeavyGPUTest = new UltraHeavyGPUTest();
            console.log('‚úÖ Ultra Heavy GPU Stress Test successfully loaded!');
        });
    </script>
    <section id="seo-content" style="display:block; padding:40px; background:#050515; color:#fff">

    <h2>What is Ultra GPU Stress Test?</h2>
    <p>
    Ultra GPU Stress Test is an advanced online GPU benchmark designed to push modern graphics cards to their absolute limits. 
    It supports RTX, AMD, and integrated GPUs directly in your browser with no installation required.
    </p>

    <h2>Why use Ultra GPU Stress Test?</h2>
    <ul>
    <li>Test GPU stability under extreme load</li>
    <li>Benchmark RTX ray tracing performance</li>
    <li>Detect overheating and throttling</li>
    <li>Works directly in browser</li>
    </ul>

    <h2>Supported Graphics Cards</h2>
    <p>
    Ultra GPU Stress Test supports NVIDIA RTX, AMD Radeon, Intel Arc and integrated GPUs.
    </p>

    <h2>GPU Stress Test FAQ</h2>
    <p><strong>Is Ultra GPU Stress Test safe?</strong><br>
    Yes, but it pushes hardware to limits. Proper cooling is recommended.</p>

    <p><strong>Do I need to install anything?</strong><br>
    No, everything runs online inside your browser.</p>

    </section>

</body>

</html>

